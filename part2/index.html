<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Random Dots Experiment</title>

    <!-- Include jsPsych CDN -->
    <script src="https://unpkg.com/jspsych@8.0.3"></script>
    <script src="https://unpkg.com/@jspsych/plugin-html-keyboard-response@2.0.0"></script>
    <script src="https://unpkg.com/@jspsych/plugin-html-button-response@2.0.0"></script>
    <script src="https://unpkg.com/@jspsych/plugin-survey-html-form@2.0.0"></script>
    <!--<script src="https://cdn.jsdelivr.net/npm/jspsych@7.2.1/jspsych.js"></script> -->
    <link rel="stylesheet" href="https://unpkg.com/@jspsych/css@8.0.0">
    

    <!-- Styling for the dots -->
    <style>
        .dot {
            width: 10px;
            height: 10px;
            background-color: black;
            border-radius: 50%;
            position: absolute;
            will-change: transform; /* Hint to the browser for GPU acceleration */
        }

        /* Center the dot container with adjustments */
        #dot-container {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 40vw;
            /* 50vw Covers 50% of the viewport width */
            height: 70vh;
            /* 50vh Covers 50% of the viewport height */
            /* transform: translate(-50%, 30%);  */
            transform: translate(-50%, 0%); 
            /* Perfectly centers the container */
            overflow: visible; 
            background-color: lightgray; /* Optional: Adds background for visibility */
            border: 1px solid black; /* Optional: Adds a border for visibility */
        } /* (-50%, 50%); (-25%, 25%);  */
        /* A: (0%, -50%)*/

        .center-stimulus {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
       
    </style>
</head>

<body>

    <script>
        // yet to fix - 
        // 1. the first frame of all animations is blank possibly because of some async issues
        // 2. the noise implementation is prob not a 100% correct. see some undefined values for stimx and noisex (also z's) printed.
        // 3. quest staircase : currently not sure where it is converging. 
        
        const centerStyle = `
        <style>
            html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            }
            .jspsych-content-wrapper {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            width: 100%;
            }
        </style>
        `;
        // Add the CSS to the document head and run the trial
        document.head.insertAdjacentHTML("beforeend", centerStyle);
        
        // BUG: FIRST DOT AT THE TOP LEFT!!
        const jsPsych = initJsPsych({
            on_finish: function() 
            {
            // const data = jsPsych.data.get().csv();
            // // Save the data as a CSV file
            // saveData("experiment_data_part2.csv", data);
            // // jsPsych.data.displayData('csv');
            }
        });

        console.log('jsPsych initialized');

        // at the start, set the stimuli for a trial
        
        // Set parameters
        const dotDur = 4; // in frames, 133ms close to 120ms
        const Nframes = 100;// 114 //100; // hardcoded for 3.3s duration
        const NdotsPerActor = 13;
        const Ndots = NdotsPerActor * 2;
        
        const noiseSpread = 200; // spread of noise from center

        const maxReversals = 20 // change maxReversals here!!

        const priorLims = [4,200];
        // Stimulus list
        const control_ = "LRswapped"; // Options: 'inverted', 'LRflipped', 'scr'

        const stimList = [
            ["help_yourself_M_A.txt", "help_yourself_M_B.txt"],
            ["help_yourself_F_A.txt", "help_yourself_F_B.txt"],
            ["this_tall_M_A.txt", "this_tall_M_B.txt"],
            ["this_tall_F_A.txt", "this_tall_F_B.txt"],
            // [`help_yourself_M_A_${control_}.txt`, `help_yourself_M_B_${control_}.txt`],
            // [`help_yourself_F_A_${control_}.txt`, `help_yourself_F_B_${control_}.txt`],
            // [`this_tall_M_A_${control_}.txt`, `this_tall_M_B_${control_}.txt`],
            // [`this_tall_F_A_${control_}.txt`, `this_tall_F_B_${control_}.txt`]
            [`help_yourself_M_B_${control_}.txt`, `help_yourself_M_A_${control_}.txt`],
            [`help_yourself_F_B_${control_}.txt`, `help_yourself_F_A_${control_}.txt`],
            [`this_tall_M_B_${control_}.txt`, `this_tall_M_A_${control_}.txt`],
            [`this_tall_F_B_${control_}.txt`, `this_tall_F_A_${control_}.txt`]
        ];

        // function normalizeVals(x) {
        //         return (x - 4) / 196; // Normalize assuming bounds 4 and 200
        //         // return 1 - ((x - 4) / 196); // Normalize and flip assuming bounds 4 and 200
        // }

        // function invNormalizeVals(x) {
        //     return x * 196 + 4; // Inverse normalization
        //     // return (1-x) * 196 + 4; // Inverse normalization
        // }

        function normalizeVals(x){ //decibelize(x){
            return -10*Math.log10(x/200)
        }

        function invNormalizeVals(x){ //invDecibelize(x){
            return 200*Math.pow(10,x/-10);
        }

        const Nstims = stimList.length;
        const Ntrials = 30; //64;

        // const NoiseLevels = [16, 48, 80, 112]; // loaded from NoiseLevels.mat
        // const NtrialsPerNoiselevel = Math.round(Ntrials / NoiseLevels.length); // 64/4 = 16
        // const NnoiseDotsAll = jsPsych.randomization.shuffle(
        // NoiseLevels.flatMap(level => Array(NtrialsPerNoiselevel).fill(level))
        // ); // shuffled array with 64 trials specifying how much noise each trial should have
        
        const NtrialsPerStim = Math.ceil(Ntrials / stimList.length); // 64/8 = 16
        const stimAll = jsPsych.randomization.shuffle(
        stimList.flatMap(level => Array(NtrialsPerStim).fill(level))
        ); // shuffled array with 64 trials specifying which stimulus to present
        // will contain repeated elements from the NoiseLevels array, where each element is repeated
        // NtrialsPerNoiselevel times.
        console.log('stimAll',stimAll)

        // console.log('NnoiseDotsAll:',NnoiseDotsAll)
        
        const NstimDots = 16; // number of stimulus dots
        const NdotsToShow = NstimDots;

        const setSize = NdotsToShow / dotDur; // number of dots changed per frame
        // console.log("Set Size:", setSize);

        // Set bounds for dot sets
        const setBounds = Array.from({ length: dotDur + 1 }, (_, i) => i * (NdotsToShow / dotDur));
        // console.log("Set Bounds:", setBounds);

        const Nsets = setBounds.length - 1; // number of sets
        // console.log("Number of Sets:", Nsets);

        // Initialize arrays
        let selTemp = Array(NdotsToShow).fill(null);
        let selStim = [];
        let f = 0;

        // Helper function to sample from an array
        function sampleFrom(N, toChooseFrom) {
            // Ensure toChooseFrom is a flat array
            if (!Array.isArray(toChooseFrom)) {
                throw new Error("toChooseFrom must be an array");
            }

            // Shuffle the array
            function shuffle(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                return array;
            }

            if (N < toChooseFrom.length) { // WHY IS 
                // If N is smaller than the length of toChooseFrom, shuffle and return the first N elements
                const sorted = shuffle([...toChooseFrom]); // Clone the array before shuffling
                return sorted.slice(0, N);
            } else {
                // If N is larger, repeat toChooseFrom enough times, shuffle, and return the first N elements
                const repeated = Array.from({ length: Math.ceil(N / toChooseFrom.length) }, () => toChooseFrom).flat();
                const sorted = shuffle(repeated);
                return sorted.slice(0, N);
            }
        }

        function getDistrInfo(array) {
            // Flatten the 2D array into a 1D array
            const flattened = array.flat();
            
            // Sort the 1D array in ascending order
            const sorted = flattened.sort((a, b) => a - b);
            
            const length = sorted.length;

            // Helper function to find the value at a specific percentile
            function getPercentile(sortedArray, percentile) {
                const index = (percentile / 100) * (sortedArray.length - 1);
                const lower = Math.floor(index);
                const upper = Math.ceil(index);
                const weight = index - lower;
                return sortedArray[lower] * (1 - weight) + sortedArray[upper] * weight;
            }

            // Calculate Q1 (25th percentile), median (50th percentile), and Q3 (75th percentile)
            const q1 = getPercentile(sorted, 25);
            const median = getPercentile(sorted, 50);
            const q3 = getPercentile(sorted, 75);

            console.log('q1, median, q3 :', q1, median, q3 )

            return { q1, median, q3 };
        }

        // Generate stimulus dots to be presented (can be scaled up to mutiple trials and doesn't depend on performance,
        // hence outside on_load)
        while (f <= Nframes + Nsets) {
            for (let s = 0; s < Nsets; s++) {
                const whichDots = Array.from({ length: setBounds[s + 1] - setBounds[s] }, (_, i) => setBounds[s] + i);
                // console.log("Which Dots:", whichDots);

                const availableDots = Array.from({ length: Ndots }, (_, i) => i + 1).filter(dot => !selTemp.includes(dot));
                selTemp.splice(setBounds[s], whichDots.length, ...sampleFrom(setSize, availableDots));
                // console.log('typeof selTemp', typeof selTemp);
                // selTemp.sort((a, b) => a - b); // sort selTemp (for later tests) --> somehow works weirdly for the 1st 4 dots so scrapped it.
                selStim.push([...selTemp]);
                f++;
            }
        }

        // Remove initial frames
        selStim = selStim.slice(Nsets, Nframes + Nsets);

        // Determine stimulus order
        const stimTrialOrder = Array.from({ length: Ntrials }, (_, i) => i % Nstims).sort(() => 0.5 - Math.random());

        function createStimulusClip(stimx, stimz, noisex, noisez, NnoiseDots, numFrames = 100, numDots = 16) {
            // function to present the stimuli
            console.log('inside createStimulusClip function')
            // numFrames = 20; // when debugging, display only for 20*33ms

            // console.log('getDimensions(stimx)',getDimensions(stimx))
            // console.log('getDimensions(stimz)',getDimensions(stimz))
            // console.log('getDimensions(noisex)',getDimensions(noisex))
            // console.log('getDimensions(noisez)',getDimensions(noisez))

            // console.log('Check stimx for undefined values:', stimx.some(row => row.some(val => val === undefined)));
            // console.log('Check stimz for undefined values:', stimz.some(row => row.some(val => val === undefined)));
            // Create the dot container
            const container = document.createElement("div");
            container.id = "dot-container";
            container.style.position = "relative";
            // container.style.width = "50vw";
            // container.style.height = "50vh";
            container.style.overflow = "visible"; // Ensure dots stay inside container

            // Create a reusable dot array
            const dots = [];
            for (let i = 0; i < numDots+NnoiseDots+1; i++) {
            // for (let i = 0; i < numDots; i++) {
                const dot = document.createElement("div");
                dot.className = "dot";
                dot.style.position = "absolute";
                dot.style.width = "5px";//"10px";
                dot.style.height = "5px";//"10px";
                dot.style.backgroundColor = "black";
                dot.style.borderRadius = "50%";
                
                // Initialize all dots with a default position off-screen
                dot.style.left = "-9999px";
                dot.style.bottom = "-9999px";

                container.appendChild(dot);
                dots.push(dot);
            }
            
            // Animation loop
            let currentFrame = 0;
            const interval = setInterval(() => {
                // if (currentFrame >= 1) { // for debugging
                if (currentFrame >= numFrames) {
                // if (currentFrame >= 1) {
                    clearInterval(interval); // End animation
                    // if (callback) callback(); // Signal completion
                    return;
                }
                // console.log(`Current Frame: ${currentFrame}, stimx:`, stimx[currentFrame], 'stimz:', stimz[currentFrame]);

                // Update dot positions for the current frame
                //present stimdots
                for (let i = 0; i < numDots; i++) {
                    dots[i].style.backgroundColor = 'black';//'white';// for debugging. "black";
                    dots[i].style.left = stimx[currentFrame][i] !== undefined 
                        ? `${stimx[currentFrame][i]}%` 
                        : (() => {
                            console.error(`Undefined value in stimx: Frame ${currentFrame}, Dot ${i}`);
                            return '50%';
                        })();

                    dots[i].style.bottom = stimz[currentFrame][i] !== undefined 
                        ? `${stimz[currentFrame][i]}%` 
                        : (() => {
                            console.error(`Undefined value in stimz: Frame ${currentFrame}, Dot ${i}`);
                            return '50%';
                        })();
                    // if (currentFrame==0){
                    //     console.log('i',i,'dots[i].style.left',dots[i].style.left,'dots[i].style.bottom',dots[i].style.bottom);
                    // }
                }

                //present noisedots
                for (let i = 0; i < NnoiseDots; i++) {
                    iDots = i + numDots
                    dots[iDots].style.backgroundColor = 'black';// for debugging "black";
                    dots[iDots].style.left = noisex[currentFrame][i] !== undefined 
                        ? `${noisex[currentFrame][i]}%` 
                        : (() => {
                            console.error(`Undefined value in noisex: Frame ${currentFrame}, Dot ${i}`);
                            return '50%';
                        })();

                    dots[iDots].style.bottom = noisez[currentFrame][i] !== undefined 
                        ? `${noisez[currentFrame][i]}%` 
                        : (() => {
                            console.error(`Undefined value in noisez: Frame ${currentFrame}, Dot ${i}`);
                            return '50%';
                        })();
                    // if (currentFrame==0){
                    // console.log('iDots',iDots,'dots[iDots].style.left',dots[iDots].style.left,'dots[iDots].style.bottom',dots[iDots].style.bottom);
                    // }
                    // console.log('currentFrame',currentFrame,',i',i,',iDots',iDots,',noisex[currentFrame][i]',noisex[currentFrame][i],',noisez[currentFrame][i]',noisez[currentFrame][i]);
                    // break;
                }
                // break
                currentFrame++;
            },33); //, 100); // , 33);   ~30 fps

            dots.forEach((dot, i) => {
            if (dot.style.left === "-9999px" || dot.style.bottom === "-9999px") {
                // console.warn(`Dot ${i} has an uninitialized position at frame ${currentFrame}.`); // FIX THIS LATER!!
                dot.style.backgroundColor = "red"; 
            } else {
                console.log(
                    `Frame ${currentFrame}, Dot ${i}: left=${dot.style.left}, bottom=${dot.style.bottom}`
                );
            }
            });
            return container;
        }

        async function test(){
            console.log('test')
        }

        function getDimensions(array) {
            const nrows_func = array.length; // Number of rows
            console.log('in func',nrows_func)
            const ncols_func = array[0]?.length || 0; // Number of columns in the first row, or 0 if empty
            console.log('in func',ncols_func)
            // return { nrows_func, ncols_func };
        }

        // Function to transpose a 2D array
        function transpose(array) {
            return array[0].map((_, colIndex) => array.map(row => row[colIndex]));
        }

        function linspace(start, end, num) {
            const step = (end - start) / (num - 1); // Calculate step size
            return Array.from({ length: num }, (_, i) => start + i * step);
        }

        // // Function to save data as a file
        function saveData(filename, data) {
            const blob = new Blob([data], { type: "text/csv" });
            const link = document.createElement("a");
            link.href = window.URL.createObjectURL(blob);
            link.download = filename;
            link.click();
        }


        function getSkewedDistribution(priorLims, initialGuess) {
            // Helper functions for normalization

            // Parameters
            const alphaMin = normalizeVals(priorLims[0]);
            const alphaMax = normalizeVals(priorLims[1]);
            const mode = normalizeVals(initialGuess); // Explicitly set mode at normalized someValue
            const stddev = normalizeVals(50);
            const variance = Math.pow(stddev,2);
            const skewDirection = 4; // Positive for right skew (long tail right), negative for left skew (long tail)

            console.log(alphaMin,alphaMax);
            
            // Calculate scale and loc
            const scale = Math.sqrt(variance);
            let loc = mode; // Set loc to the mode directly
            const shape = skewDirection; // Skew direction and intensity

            // Generate x values
            const x = Array.from({ length: priorLims[1] - priorLims[0] }, (_, i) => 
                alphaMin + i * ((alphaMax - alphaMin) / (priorLims[1] - priorLims[0]))
            );

            console.log("x:", x);

            // Calculate y values (skewed distribution)
            let y = x.map(val => {
                return skewnormPDF(val, shape, loc, scale);
            });

            // Ensure the actual mode aligns with the desired mode
            const actualModeIndex = y.indexOf(Math.max(...y));
            const actualMode = x[actualModeIndex];

            // Adjust loc so the mode aligns exactly with the desired value
            const locCorrection = mode - actualMode;
            loc += locCorrection;

            // Recalculate y with adjusted loc
            y = x.map(val => {
                return skewnormPDF(val, shape, loc, scale);
            });

            y = y.map(val => val / y.reduce((sum, v) => sum + v, 0));

            return y;

            // Helper function to calculate skewnorm PDF
            function skewnormPDF(x, shape, loc, scale) {
                const t = (x - loc) / scale;
                const phi = Math.exp(-0.5 * t * t) / Math.sqrt(2 * Math.PI);
                const PHI = 0.5 * (1 + erf(shape * t / Math.SQRT2));
                return (2 / scale) * phi * PHI;
            }

            // Helper function for error function approximation
            function erf(x) {
                // Numerical approximation for erf(x)
                const sign = x >= 0 ? 1 : -1;
                x = Math.abs(x);
                const a1 = 0.254829592,
                    a2 = -0.284496736,
                    a3 = 1.421413741,
                    a4 = -1.453152027,
                    a5 = 1.061405429;
                const p = 0.3275911;

                const t = 1 / (1 + p * x);
                const y = 1 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);
                return sign * y;
            }
        }

        // let test1 = 0;

        let dotTrial, respPage, threshold_unnorm, breakPage, endPage;

        breakPage = {
                    type: jsPsychSurveyHtmlForm,
                    // stimulus:'<div class="center-stimulus"> Welcome!</div>',
                    // stimulus: '<p style="text-align: center;">Welcome to this study!<br>Here you will watch several short animations and answer questions about them.</p>',
                    html: '<p style="text-align: center; width: 400px">Short break.<br><br>Continue when you are ready.</p>',
                    //         html: `
                    // <div style="text-align: center;">
                    //     <p>Welcome to this study!<br>Here you will watch several short animations and answer questions about them.</p>
                    //     <button type="submit" style="display: inline-block; margin: 20px auto; padding: 10px 20px; font-size: 16px;">Continue</button>
                    // </div>
                    // `
                    on_load: function() {
                        // Wait for the button to exist
                        setTimeout(() => {
                            const button = document.querySelector(".jspsych-survey-html-form-next");
                            if (button) {
                                button.style.cssText = `
                                    display: block;
                                    margin: 20px auto;
                                    text-align: center;
                                `;
                            }
                        }, 100); // Small delay to ensure element is rendered
                    }
        };

        let timeline = [];

        introPage = {
                type: jsPsychSurveyHtmlForm,
                // stimulus:'<div class="center-stimulus"> Welcome!</div>', 
                // stimulus: '<p style="text-align: center;">Welcome to this study!<br>Here you will watch several short animations and answer questions about them.</p>',
                // html: '<p style="text-align: left;">Part 2: Threshold estimation (remove from subs)<br><br>Here you will watch short animation clips and<br>answer questions about<br>(1) whether the social interaction in each clip was<br>upright or inverted, <br>(2) how confident you feel about your response.</p>',
                html: '<p style="text-align: center; width: 400px"><b>Part 2</b><br><br>In this part, you will see moving dots that depict interacting people, but the interactions will be embedded in noise.<br>After each clip, you must indicate which of the two interactions was presented.</p>',
                // on_load: function() {
                //     // Wait for the button to exist
                //     setTimeout(() => {
                //         const button = document.querySelector(".jspsych-survey-html-form-next");
                //         if (button) {
                //             button.style.cssText = `
                //                 display: block;
                //                 margin: 20px auto;
                //                 text-align: center;
                //             `;
                //         }
                //     }, 100); // Small delay to ensure element is rendered
                on_load: function() {
                const buttons = document.querySelectorAll('.jspsych-btn');
                buttons.forEach(button => {
                    button.style.display = 'block';
                    button.style.margin = '0 auto';
                });
                }
            };
        timeline.push(introPage)
        
        const initialGuess = 32;
        let quest = {
            // threshold: 49, // from pilot data (unnorm.), 70% threshold.
            // beta: -0.00178, // from pilot data (unnorm.) //-0.35 for norm. // Slope of the Weibull function
            threshold: normalizeVals(initialGuess), // assuming the number of dots can only go from 4 to 200. 1-(x-4)/196 normalizes and flips x.
            // threshold: (70-4)/196,
            // threshold: 0.23, // from pilot data (norm. wrt 4-200 dots), 70% threshold.
            beta: 3.5, //0.33,//-0.33, // for debugging, positive b. lastv beta positive
            // beta: -0.33, // from pilot data (norm. wrt 4-200 dots). Slope of the Weibull function
            gamma: 0.5, // Guess rate (Nchoices = 2; 1/Nchoices)
            epsilon: 1.5,
            lambda: 0.02, // Lapse rate
            trials: [], // Array to store trial results
            allThresholds: [], // to store meanAlpha from each trial
            nReversals: 0,
            // priorRange: Array.from({ length: 197 }, (_, i) => 4 + i), // Range [4, 200]
            // pdf: Array(197).fill(1 / 197), // Uniform prior

            // priorRange: Array.from({ length: 61 }, (_, i) => 20 + i), // Range [20, 80]. don't need to normalize since they are array indices. but should normalize these whenever making guesses
            // pdf: Array(61).fill(1 / 61).map(val => Math.round(val * 100) / 100), // Uniform prior
            priorRange: Array.from({ length: priorLims[1]-priorLims[0] }, (_, i) => priorLims[0] + i), // Range [20, 200]. don't need to normalize since they are array indices. but should normalize these whenever making guesses
            // pdf: Array(181).fill(1 / 181).map(val => Math.round(val * 100) / 100), // Uniform prior
            pdf:getSkewedDistribution(priorLims,initialGuess), // normalized skewed function
            
            weibull: function (alpha, x) { // Weibull psychometric function
                // const targetAccuracy = 0.7;
                // const targetp =  targetAccuracy; 
                // const targetp = 1 - targetAccuracy; // pwrong
                // const { beta, gamma, lambda } = this; // const { beta, gamma, lambda } = this;
                const beta  = this.beta;
                const gamma = this.gamma;
                const lambda = this.lambda;
                // const targetFactor = (targetp - gamma) / (1 - gamma - lambda); // Scale for some % accuracy
                // const adjustment = Math.pow(-Math.log(1 - targetFactor), (1 / beta));  // Compute scale adjustment
                const epsilon = this.epsilon
                // console.log('epsilon',epsilon);
                // const x_adjusted = Math.pow(-Math.log(1 - targetFactor), 1 / beta);  // Compute scale adjustment
                // return gamma + (1 - gamma - lambda) * (1 - Math.exp(-Math.pow(10,beta*(x-alpha))));  // gumbel
                // return gamma + (1 - gamma - lambda) * (1 - Math.exp(-Math.pow(10,beta*(x-alpha/adjustment)))); 
                return gamma + (1 - gamma - lambda) * (1 - Math.exp(-Math.pow(10,beta*(x - alpha + epsilon)))); 

                // p = gamma + (1 - gamma - lambda) * (1 - Math.exp(-Math.pow(x / (alpha * adjustment), beta))); 
                // p = 1-p; // to make changes steep (added by RV after Jupyter notebook visualizations). 
                // return p;// weibull probability for wrong (bc its peak is at the start)
                // return gamma + (1 - gamma - lambda) * (1 - Math.exp(-Math.pow(x / alpha, beta)));
            },

            // Calculate next stimulus
            nextStimulus: function () { //on_load stimulus page
                console.log('QUEST nextStimulus method called');
                console.log('this.trials', this.trials);
                console.log('this.trials.length',this.trials.length)
                if (this.trials.length === 0) return this.threshold; // First trial

                // Choose the mode (highest probability) of the posterior
                // const maxIndex = this.pdf.indexOf(Math.max(...this.pdf));
                // console.log('maxIndex',maxIndex)
                // let threshold_ind = this.priorRange[maxIndex];
                // trying mean instead of mode for debugging
                // let threshold_temp = threshold_ind - 4;
                // this.threshold = threshold_temp/196;
                const weightedSum = this.priorRange.reduce((sum, alpha, i) => sum + alpha * this.pdf[i], 0);
                const meanAlpha = weightedSum / this.pdf.reduce((sum, p) => sum + p, 0);
                threshold_unnorm = meanAlpha;
                this.threshold = normalizeVals(threshold_unnorm);
                // this.threshold = this.threshold - 4;
                // this.threshold = this.threshold/196;
                
                console.log('this.threshold',  this.threshold)
                // Ensure the threshold stays within the range
                // this.threshold = Math.min(Math.max(this.threshold, 4), 200);
                // if (this.threshold < normalizeVals(200)) // roughly 80 dots
                if (threshold_unnorm > 200) // roughly 80 dots
                    {
                        this.threshold = normalizeVals(200)
                    }
                
                // if (this.threshold > normalizeVals(20)) // < 20 dots
                if (threshold_unnorm < 20) // < 20 dots
                    {
                        this.threshold = normalizeVals(20); //0.08
                    }
                this.allThresholds.push(this.threshold); // add new threshold estimate
                console.log('this.threshold final',  this.threshold)

                return this.threshold; // normalized
            },

            // Update posterior PDF
            updatePdf: function (correct, stimulus) { // called from addResponse (end of response trial). stimulus is the number of dots in the stimulus and is unnormalized.
                // stimulus = stimulus-4 // normalizing stimulus
                // stimulus = stimulus/196
                stimulus = normalizeVals(stimulus);
                var likelihood = this.priorRange.map(alpha => {
                    alpha = normalizeVals(alpha);
                    const p = this.weibull(alpha, stimulus); // this p is already 1-p (what we want)
                    console.log('Alpha:', alpha, 'Stimulus:', stimulus, 'Weibull Output:', p);
                    return p;
                    // console.log(`Alpha: ${alpha}, Likelihood: ${correct ? p : 1 - p}`);
                    // return correct ? p : 1 - p; // Correct response: p, Incorrect response: 1-p. Does not return to updatePdf
                }); // likelihood is an array of the same size as priorrange (from mindots to maxdots, e.g., 4 to 200), and contains 
                // the probability of each of those prior values. the probability is p if the last response was correct, and (1-p) if it was wrong.
                // here, p is the probability that the response is correct for evidence (ndots) on that trial ('stimulus')
                // console.log('inside updatePdf below return')
                // Update and normalize the posterior PDF
                
                // if (correct==0){
                if (correct==1){ // if correct, have the high value on the higher end
                    likelihood.reverse();
                }

                // Normalize the likelihood array
                const likelihoodSum = likelihood.reduce((sum, val) => sum + val, 0);
                likelihood = likelihood.map(val => val / likelihoodSum);

                console.log('Prior:', this.pdf);
                this.pdf = this.pdf.map((p, i) => p * likelihood[i]);
                // console.log('inside updatePdf, pdf:', this.pdf)
                const normalizationFactor = this.pdf.reduce((sum, val) => sum + val, 0);
                this.pdf = this.pdf.map(p => p / normalizationFactor);
                console.log('Posterior:', this.pdf);
                // Round each probability in the normalized PDF to two decimal places
                this.pdf = this.pdf.map(p => parseFloat(p.toFixed(4))); // Rounding to 2 decimal places
                console.log('inside updatePdf, pdf after normalization and rounding:', this.pdf);

                return likelihood;
            },

            countReversal: function (){
                // Get the last 3 elements
                let lastThree = this.allThresholds.slice(-3);

                // Access each element separately
                let thirdLast = lastThree[0]; // First of the last 3
                let secondLast = lastThree[1]; // Second of the last 3
                let last = lastThree[2]; // Last element
                
                if ( ((secondLast > last) && (thirdLast < secondLast) ) ||
                     ((secondLast < last) && (thirdLast > secondLast) )) 
                // if ( ((this.allThresholds[n-1] > this.allThresholds[n]) && (this.allThresholds[n-2] < this.allThresholds[n-1]) ) ||
                // ((this.allThresholds[n-1] < this.allThresholds[n]) && (this.allThresholds[n-2] > this.allThresholds[n-1]) )) 
                    {
                        this.nReversals++;
                    }
                    return this.nReversals;
            },
            // Add response to trials and update the posterior
            addResponse: function (stimulus, correct) { // end of response page. stimulus is not normalized
                console.log('QUEST addResponse method called');
                this.trials.push({ stimulus, correct });
                const likelihood = this.updatePdf(correct, stimulus); // Update posterior using the response. stimulus is not normalized
                return likelihood;
            }
        };
        
        let NnoiseDots;
        // for (let jj = 1; jj<Ntrials+1; jj++) {
        for (let jj = 0; jj<Ntrials; jj++) {
            
            if (quest.nReversals > maxReversals)
            {
                break;
            }
            
            let start_time;
            dotTrial = {
                type:  jsPsychHtmlKeyboardResponse,
                stimulus: function () {
                    return `<div id="dot-container" style="position: relative; width: 40vw; height: 70vh;"></div>`;
                },
                choices: 'NO_KEYS',
                on_load: async function () {
                    
                    // for each trial, first read the stim file, shift and scale values, concat across agents etc. (only stim)
                    // stim stuff begins
                    const indA = stimTrialOrder[jj - 1];
                    const indB = indA;
                    // const NnoiseDots = NnoiseDotsAll[jj]; // when showing fixed levels
                    // const NnoiseDots = 48 // when developing code
                    // const NnoiseDots = quest.nextStimulus(); // for staircase
                    NnoiseDots = quest.nextStimulus(); // for staircase
                    NnoiseDots = Math.round(invNormalizeVals(NnoiseDots));//NnoiseDots*196 + 4)
                    console.log('jj',jj,'NnoiseDots',NnoiseDots);
                    // const stimFileA = `stims/${stimList[indA][0]}`;
                    // const stimFileB = `stims/${stimList[indB][1]}`;
                    // let vid_name = 'come_closer_F'; //'look_ceiling_F';
                    let curr_stim = stimAll[jj]; 
                    console.log('curr_stim',curr_stim)
                    // const stimFileA = `stims/${vid_name}_A.txt`;
                    // const stimFileB = `stims/${vid_name}_B.txt`;
                    const stimFileA = `stims/${curr_stim[0]}`;
                    const stimFileB = `stims/${curr_stim[1]}`;

                    console.log("File path for A:", stimFileA);
                    console.log("File path for B:", stimFileB);


                    let dataA = await fetch(`./${stimFileA}`); //await fetch('./come_closer_F_A.txt');
                    let dataB = await fetch(`./${stimFileB}`); //await fetch('./come_closer_F_A.txt');
                    
                    textA = await dataA.text();
                    textB = await dataB.text();

                    console.log('dataA:',dataA)

                    const linesA = textA.trim().split('\n');// Split the data into lines and skip the first line (header)
                    const linesB = textB.trim().split('\n');// Split the data into lines and skip the first line (header)
                    
                    // Handle header if i = 0
                    // const header = i === 0 ? lines[0] : null;
                    const headerA = linesA[0]; // Always take the first line as the header
                    const headerB = linesB[0]; // Always take the first line as the header
                    console.log('headerA',headerA)
                    const totFrames = headerA.match(/frames\s*=\s*(\d+)/)[1]; // tot frames is useful to reshape the array
                    console.log('totFrames',totFrames)
                    const bodyA = linesA.slice(1);
                    const bodyB = linesB.slice(1);
                    const columnsA = bodyA.map(line => {
                        const parts = line.trim().split(/\s+/); // Split line by whitespace
                        return [parseFloat(parts[0]), parseFloat(parts[2])]; // Extract columns 0 and 2 as numbers
                    });
                    const columnsB = bodyB.map(line => {
                        const parts = line.trim().split(/\s+/); // Split line by whitespace
                        return [parseFloat(parts[0]), parseFloat(parts[2])]; // Extract columns 0 and 2 as numbers
                    });
                    // console.log('columnsA',columnsA, ',columnsA.length()', columnsA.length)//, ',test1:',test1)
                    // console.log('columnsB',columnsB, ',columnsB.length()', columnsB.length)//, ',test1:',test1)
                    
                    // Get dimensions
                    // console.log('columnsA dims')
                    // getDimensions(columnsA);
                    // console.log('columnsB dims')
                    // getDimensions(columnsB);

                    // Separate columns
                    ax = columnsA.map(row => row[0]); // Extract first column
                    az = columnsA.map(row => row[1]); // Extract second column
                    // console.log('ax',ax,typeof ax[0]); // Output: "number"

                    bx = columnsB.map(row => row[0]); // Extract first column
                    bz = columnsB.map(row => row[1]); // Extract second column
                    // console.log('bx',bx,typeof bx[0]); // Output: "number"

                    /* shift and scale! */
                    let shift=50;
                    let scale=20;
                    // Find the minimum and maximum values
                    let min = Math.min(...ax);
                    let max = Math.max(...ax);
                    // Center and normalize the array
                    ax = ax.map(num => (num - min) / (max - min));
                    // console.log('ax after norm',ax,typeof ax[0]); // Output: "number"
                    ax = ax.map(num => num * scale + shift);
                    // console.log('ax after shift and scale',ax,typeof ax[0]); // Output: "number"

                    min = Math.min(...ax);
                    max = Math.max(...ax);
                    // console.log('ax: min', min,',max', max)

                    shift=30//-20;
                    // scale=20; // scale should be the same for both x's
                    // Find the minimum and maximum values
                    min = Math.min(...bx);
                    max = Math.max(...bx);
                    bx = bx.map(num => (num - min) / (max - min));
                    // console.log('bx after norm',bx,typeof bx[0]); // Output: "number"
                    bx = bx.map(num => num * scale + shift);
                    // console.log('bx after shift and scale',bx,typeof bx[0]); // Output: "number"

                    min = Math.min(...bx);
                    max = Math.max(...bx);
                    // console.log('bx: min', min,',max', max)
                    
                    shift=20//-30; // same shift and scale for both 
                    scale=60;
                    // vertical
                    // Find the minimum and maximum values
                    min = Math.min(...az);
                    max = Math.max(...az);
                    // Center and normalize the array
                    az = az.map(num => (num - min) / (max - min));
                    az = az.map(num => num * scale + shift);

                    min = Math.min(...az);
                    max = Math.max(...az);
                    // console.log('az: min', min,',max', max)
                    
                    // // Find the minimum and maximum values
                    min = Math.min(...bz);
                    max = Math.max(...bz);
                    // Center and normalize the array
                    bz = bz.map(num => (num - min) / (max - min));
                    bz = bz.map(num => num * scale + shift);

                    min = Math.min(...bz);
                    max = Math.max(...bz);
                    // console.log('bz: min', min,',max', max)

                    // console.log('ax not reshaped',ax)
                    let rows = totFrames;
                    let cols = 13;
                    // ax = reshape(ax, NdotsPerActor);
                    // az = reshape(az, NdotsPerActor);
                    ax = Array.from({ length: rows }, (_, i) => 
                            ax.slice(i * cols, (i + 1) * cols)
                    );
                    az = Array.from({ length: rows }, (_, i) => 
                            az.slice(i * cols, (i + 1) * cols)
                    );
                    
                    // Get dimensions
                    // console.log('ax reshaped',ax)
                    // console.log('ax dims')
                    // getDimensions(ax);

                    // console.log('bx not reshaped',bx)
                    bx = Array.from({ length: rows }, (_, i) => 
                            bx.slice(i * cols, (i + 1) * cols)
                    );
                    bz = Array.from({ length: rows }, (_, i) => 
                            bz.slice(i * cols, (i + 1) * cols)
                    );
                    // Get dimensions
                    // console.log('bx reshaped',bx)
                    // console.log('bx dims')
                    // getDimensions(bx);
                    
                    let stimx = [];
                    let stimz = [];
                    // console.log('selStim',selStim)
                    console.log('Nframes',Nframes)
                    ax_bx = ax.map((row, i) => row.concat(bx[i]));  //ax.concat(bx);
                    az_bz = az.map((row, i) => row.concat(bz[i]));  //ax.concat(bx);
                    // console.log('ax')
                    // getDimensions(ax)
                    // console.log('bx')
                    // getDimensions(bx)
                    // console.log('ax_bx',ax_bx)
                    // getDimensions(ax_bx)
                    min = Math.min(...ax_bx.flat());
                    max = Math.max(...ax_bx.flat());
                    // console.log('ax_bx : min', min,',max', max)
                    min = Math.min(...az_bz.flat());
                    max = Math.max(...az_bz.flat());
                    // console.log('az_bz : min', min,',max', max)
                    // end of stim stuff

                    // start of noise stuff

                    NdotsToShowNoise = NnoiseDots; 
                    setSizeNoise = NdotsToShowNoise/dotDur // as framerate is 30Hz, I will change a dot every 4 frames, so to make the changes as asynchroneous as possible, I change as few dots as possible - that's 3 per frame
                    setBoundsNoise = linspace(0,NdotsToShowNoise,dotDur+1) // start and stop of each quarter.
                    setBoundsNoise = setBoundsNoise.map(num => Math.ceil(num));
                    console.log('setBoundsNoise',setBoundsNoise)

                    const possCoordsNoisex = transpose(ax_bx);
                    const possCoordsNoisez = transpose(az_bz);
                    // console.log('possCoordsNoisex',possCoordsNoisex,'possCoordsNoisex.length',possCoordsNoisex.length)
                    
                    // Initialize arrays (which are later combined to generate noise) with 0
                    let offsetx = Array.from({ length: NnoiseDots }, () =>
                    Array(Nframes).fill(0)
                    );
                    let offsetz = Array.from({ length: NnoiseDots }, () =>
                    Array(Nframes).fill(0)
                    );
                    let timeWindow = Array.from({ length: NnoiseDots }, () =>
                    Array(Nframes).fill(0)
                    );
                    let swapXZ = Array.from({ length: NnoiseDots }, () =>
                    Array(Nframes).fill(0)
                    );
                    let flipX = Array.from({ length: NnoiseDots }, () =>
                    Array(Nframes).fill(1)
                    );
                    let flipZ = Array.from({ length: NnoiseDots }, () =>
                    Array(Nframes).fill(1)
                    );
                    console.log('offsetx[0][0]:',offsetx[0][0]) // sanity check. should be 0

                    // Initialize `sel` as a 2D array with NnoiseDots rows and (Nframes + Nsets) columns, filled with NaN
                    let sel = Array.from({ length: NnoiseDots }, () => 
                        Array(Nframes + Nsets).fill(NaN)
                    );
                    // console.log('sel.length',sel.length,',sel:',sel)
                    // Select and transform dots
                    let f = 0; // Frame counter
                    // const selTemp = Array.from({ length: NnoiseDots }, () => NaN);
                    // const offsetxTemp = Array.from({ length: NnoiseDots }, () => NaN);
                    // const offsetzTemp = Array.from({ length: NnoiseDots }, () => NaN);
                    // const timeWindowTemp = Array.from({ length: NnoiseDots }, () => NaN);
                    // const swapXZTemp = Array.from({ length: NnoiseDots }, () => NaN);
                    // const flipXTemp = Array.from({ length: NnoiseDots }, () => NaN);
                    // const flipZTemp = Array.from({ length: NnoiseDots }, () => NaN);

                    while (f <= Nframes + Nsets) { // repmat not working!!!!!
                        for (let s = 0; s < Nsets; s++) { // for each set of NnoiseDots/4 dots
                            const whichDots = Array.from(
                            { length: setBoundsNoise[s + 1] - setBoundsNoise[s] },
                            (_, i) => setBoundsNoise[s] + i
                            ); // should be something like 0-12, 12-24 etc
                            // console.log('whichDots:',whichDots) // this is correct
                            const range = Array.from({ length: Ndots }, (_, i) => i); // 1:Ndots (1:26) --> inds from which to select stimuli
                            let sampled = sampleFrom(Math.ceil(NnoiseDots/dotDur), range);  // sample 16 dots
                            // console.log('sampled:',sampled) // (should be 12 values between 1 and 26 from the stim dots for Noisedots=48)
                            // edit a quarter of dots
                            samp = -1;
                            whichDots.forEach((dot) => { // for each of the 12 dots (48 noisedots version). e.g. dot goes from 36 to 47
                                samp++;
                                // selTemp[dot] = sampled[samp]
                                // offsetxTemp[dot] = (Math.random() - 0.5) * noiseSpread;
                                // offsetzTemp[dot] = (Math.random() - 0.5) * noiseSpread; 
                                // timeWindowTemp[dot] = Math.floor(Math.random() * (Nframes - 3));
                                // swapXZTemp[dot] =  Math.round(Math.random());
                                // flipXTemp[dot] = Math.random() < 0.5 ? -1 : 1; 
                                // flipZTemp[dot] = Math.random() < 0.5 ? -1 : 1; 
                                // selTemp[dot] = sampled[samp]

                                // assign temporary values to each dot within the set
                                main_dot_ind = sampled[samp] //selTemp[dot]; // sel has the dot number (wrt the main stim set) 
                                // console.log('dot',dot,'main_dot_ind',main_dot_ind)
                                // for each of the 48 dots and Nframes+4 frames
                                offsetxTemp_ = (Math.random() - 0.5) * noiseSpread;
                                offsetzTemp_ = (Math.random() - 0.5) * noiseSpread; 
                                timeWindowTemp_ = Math.floor(Math.random() * (Nframes - 3));
                                swapXZTemp_ =  Math.round(Math.random());
                                flipXTemp_ = Math.random() < 0.5 ? -1 : 1; 
                                flipZTemp_ = Math.random() < 0.5 ? -1 : 1; 

                                for (let ind = 0; ind < 4; ind++){ // repmat in matlab
                                    sel[dot][f+ind] = main_dot_ind
                                    offsetx[dot][f+ind] = offsetxTemp_ //offsetxTemp[dot]; // Random x-offset
                                    offsetz[dot][f+ind] = offsetzTemp_ //offsetzTemp[dot]; // Random z-offset
                                    timeWindow[dot][f+ind] = timeWindowTemp_ + ind; //timeWindowTemp[dot]+ind;
                                    swapXZ[dot][f+ind] = swapXZTemp_; // swapXZTemp[dot];
                                    flipX[dot][f+ind] = flipXTemp_; //flipXTemp[dot];
                                    flipZ[dot][f+ind] = flipZTemp_; //flipZTemp[dot];
                                }
                            });
                            // console.log('offsetxTemp',offsetxTemp);
                            f++;
                        }
                    }
                    // console.log('after sel.length',sel.length,',sel:',sel)
                    // console.log('before splicing.. offsetx',offsetx)
                    // console.log('offsetx[0][0]:',offsetx[0][0])
                    // sel = sel.slice(Nsets, Nframes + Nsets); // Remove initial frames
                    // console.log('before, sel',sel)
                    sel = sel.map(row => row.slice(Nsets,Nframes+Nsets));
                    // console.log('after, sel',sel)
                    offsetx = offsetx.map(row => row.slice(Nsets,Nframes+Nsets));
                    offsetz = offsetz.map(row => row.slice(Nsets,Nframes+Nsets));

                    // console.log('after sel.length',sel.length,',sel:',sel)
                    // console.log('after splicing..offsetx',offsetx)
                    // console.log('offsetx[0][0]:',offsetx[0][0])

                    let noisex = Array.from({ length: Nframes }, () =>
                    Array(NnoiseDots).fill(0)
                    );
                    let noisez = Array.from({ length: Nframes }, () =>
                    Array(NnoiseDots).fill(0)
                    );
                    
                    // console.log('noise initialised...')
                    // console.log('noisex dimensions:', noisex.length, noisex[0]?.length || 0);
                    // console.log('noisez dimensions:', noisez.length, noisez[0]?.length || 0);

                    
                    for (let f = 0; f < Nframes; f++) {
                        for (let d = 0; d < NnoiseDots; d++) {
                            // console.log('before:')

                            // console.log('possCoordsNoisex dimensions:', possCoordsNoisex.length, possCoordsNoisex[0]?.length || 0);
                            // console.log('offsetx dimensions:', offsetx.length, offsetx[0]?.length || 0);
                    
                            // console.log('frame',f,', dot',d);
                            // console.log('sel[d][f]',sel[d][f]);
                            // console.log('timeWindow[d][f]',timeWindow[d][f]);
                            // console.log('possCoordsNoisex[sel[d][f]][timeWindow[d][f]]',possCoordsNoisex[sel[d][f]][timeWindow[d][f]]);
                            // console.log('offsetx[sel[d][f]][timeWindow[d][f]]',offsetx[d][timeWindow[d][f]]);//[sel[d][f]][timeWindow[d][f]]); // just need 'd' here. E.g if the dot is 26 in the actual dot array, for the offset, it' still a value between 1 and Nnoisedots
                            // console.log('noisez[d][f]',noisez[d][f]);

                            if (swapXZ[d][f]) 
                            {
                                // Perform coordinate swap and offset adjustment
                                // noisex[d][f] =
                                noisex[f][d] =
                                    flipX[d][f] *
                                    possCoordsNoisez[sel[d][f]][timeWindow[d][f]] +
                                    offsetx[d][timeWindow[d][f]]; // offsetx[sel[d][f]][timeWindow[d][f]];  just need 'd' here. E.g if the dot is 26 in the actual dot array, for the offset, it' still a value between 1 and Nnoisedots
                                // noisex[f][d] =
                                noisez[f][d] = 
                                    flipZ[d][f] *
                                    possCoordsNoisex[sel[d][f]][timeWindow[d][f]] +
                                    offsetz[d][timeWindow[d][f]]; // offsetz[sel[d][f]][timeWindow[d][f]];
                            } 
                            else 
                            {
                                // Standard coordinate adjustment
                                noisex[f][d] =
                                    flipX[d][f] *
                                    possCoordsNoisex[sel[d][f]][timeWindow[d][f]] +
                                    offsetx[d][timeWindow[d][f]]; //offsetx[sel[d][f]][timeWindow[d][f]];
                                noisez[f][d] =
                                    flipZ[d][f] *
                                    possCoordsNoisez[sel[d][f]][timeWindow[d][f]] +
                                    offsetz[d][timeWindow[d][f]]; // //offsetz[sel[d][f]][timeWindow[d][f]];
                            }
                            // console.log('after:')
                            // console.log('frame',f,', dot',d);
                            // console.log('sel[d][f]',sel[d][f]);
                            // console.log('timeWindow[d][f]',timeWindow[d][f]);
                            // console.log('possCoordsNoisex[sel[d][f]][timeWindow[d][f]]',possCoordsNoisex[sel[d][f]][timeWindow[d][f]]);
                            // console.log('offsetx[sel[d][f]][timeWindow[d][f]]',offsetx[d][timeWindow[d][f]]);
                            // console.log('noisez[d][f]',noisez[d][f]);
                        }
                    }
                    console.log('noisex.length',noisex.length, ', noisex[0]?.length || 0',  noisex[0]?.length || 0)
                    // console.log('noisex',noisex)

                    /* shift and scale noise!! */
                    shift=0;
                    scale=100;
                    // Find the minimum and maximum values
                    min = Math.min(...noisex.flat());
                    max = Math.max(...noisex.flat());
                    // console.log('before: noisex: min', min,',max', max) // there is a bug already before!!
                    // Center and normalize the array
                    noisex = noisex.map(row => row.map(num => (num - min) / (max - min)) ); //noisex.map(num => (num - min) / (max - min));
                    noisex = noisex.map(row => row.map(num => num * scale + shift));
                    // console.log('ax after shift and scale',ax,typeof ax[0]); // Output: "number"
                    min = Math.min(...noisex.flat());
                    max = Math.max(...noisex.flat());
                    // console.log('noisex after : min', min,',max', max)
                    

                    shift=0//-30; // same shift and scale for both 
                    scale=100 //100;
                    // vertical
                    // Find the minimum and maximum values
                    min = Math.min(...noisez.flat());
                    max = Math.max(...noisez.flat());
                    // console.log('noisez before: min', min,',max', max)

                    // Center and normalize the array
                    noisez = noisez.map(row => row.map(num => (num - min) / (max - min)));
                    noisez = noisez.map(row => row.map(num => num * scale + shift));

                    min = Math.min(...noisez.flat());
                    max = Math.max(...noisez.flat());
                    console.log('noisez after: min', min,',max', max)
                    getDistrInfo(noisez)

                    // end of noise stuff

                    for (let f = 0; f < Nframes; f++) {
                        // console.log(`Frame ${f} selStim[f]:`, selStim[f]); // debug
                        // console.log(f)
                        // stimx.push(selStim[f].map(index => ax_bx[f][index - 1]));
                        // stimz.push(selStim[f].map(index => az_bz[f][index - 1]));

                        stimx.push(
                            selStim[f].map(index => {
                                if (ax_bx[f][index - 1] === undefined) {
                                    console.error(`Undefined in stimx at frame ${f}, index ${index - 1}`);
                                }
                                return ax_bx[f][index - 1];
                            })
                        );

                        stimz.push(
                            selStim[f].map(index => {
                                if (az_bz[f][index - 1] === undefined) {
                                    console.error(`Undefined in stimz at frame ${f}, index ${index - 1}`);
                                }
                                return az_bz[f][index - 1];
                            })
                        );
                        // stimx.push(selStim[f].map(index => ax.concat(bx)[index - 1][f]));
                        // stimz.push(selStim[f].map(index => az.concat(bz)[index - 1][f]));
                    }
                    // console.log('stimx dimensions:', stimx.length, stimx[0]?.length || 0);
                    // console.log('stimz dimensions:', stimz.length, stimz[0]?.length || 0);
                    // console.log('stimx',stimx)
                    // getDimensions(stimx)
                    // console.log('stimz',stimz)
                    // getDimensions(stimz)

                    // console.log('noisex dimensions:', noisex.length, noisex[0]?.length || 0);
                    // console.log('noisez dimensions:', noisez.length, noisez[0]?.length || 0);
                    // console.log('noisex',noisex)
                    // getDimensions(noisex)
                    // console.log('noisez',noisez)
                    // getDimensions(noisez)

                    min = Math.min(...stimx.flat());
                    max = Math.max(...stimx.flat());
                    // console.log('stimx: min', min,',max', max)
                    
                    min = Math.min(...stimz.flat());
                    max = Math.max(...stimz.flat());
                    // console.log('stimz: min', min,',max', max)

                    min = Math.min(...noisex.flat());
                    max = Math.max(...noisez.flat());
                    // console.log('noisex: min', min,',max', max)

                    min = Math.min(...noisex.flat());
                    max = Math.max(...noisez.flat());
                    // console.log('noisez: min', min,',max', max)

                    const container = document.getElementById("dot-container");
                    if (container) {
                        start_time = performance.now(); // Record start time
                        container.replaceWith(createStimulusClip(stimx, stimz, noisex, noisez, NnoiseDots, Nframes, NstimDots));
                        // container.replaceWith(
                        //     createStimulusClip(stimx, stimz, noisex, noisez, NnoiseDots, Nframes, NstimDots, () => {
                        //         const end_time = performance.now();
                        //         const duration = end_time - start_time;
                        //         jsPsych.endTrial({
                        //             page_duration: duration
                        //         });
                        //     })
                        // );
                        // const end_time = performance.now(); // Record end time
                        // const duration = end_time - start_time; // Calculate duration
                        // jsPsych.endTrial({
                        //     page_duration: duration // Save duration in trial data
                        // });
                    } else {
                        console.error("Dot container not found!");
                    }
                },
                // on_start: function (trial) {
                //     dotTrial.start_time = performance.now(); // Record start time
                // },
                on_finish: function(data){
                    //    data.page_duration = duration; // Save to trial data
                    const end_time = performance.now(); // Record end time
                    const duration = Math.round(end_time - start_time); // Calculate duration
                    data.page_duration = duration; // Save to trial data
                    data.stimName = stimAll[jj]; 
                    data.numNoiseDots = NnoiseDots; //NnoiseDotsAll[jj];
                },
                trial_duration: 3200 // End trial after the whole clip
                // trial_duration: 500 // End trial after a short period WHEN DEBUGGING!
            };
            timeline.push(dotTrial);
            
            let start_time_resp; // Declare globally

            respPage = {
                type: jsPsychHtmlButtonResponse,
                // stimulus: '<div class="center-stimulus"> Press a button!;</div>',
                stimulus: '<p style="text-align: center;">Press a button!</p>',
                choices: ['Help yourself', 'This tall'],
                prompt: " ",
                on_start: function(){
                    start_time_resp = performance.now(); // Record start time
                },
                on_finish: function(data){
                    // Score the keyboard response as correct or incorrect.
                    // Check if 'inverted' is in stimFileA
                    // data.response = ['Upright', 'Inverted'][data.response]
                    data.response = ['Help yourself', 'This tall'][data.response]
                    // const true_label = stimAll[jj][0].includes("inverted") ? "Inverted" : "Upright"; // '.includes("inverted") ' --> has to be lowercase!
                    const true_label = stimAll[jj][0].includes("help") ? "Help yourself" : "This tall"; // '.includes("inverted") ' --> has to be lowercase!
                    data.true_label = true_label;
                    try {
                        if(jsPsych.pluginAPI.compareKeys(data.response, true_label)){
                        data.correct = 1;
                        } else {
                        data.correct = 0; 
                        }
                    } 
                    catch (error) 
                    {
                        console.error("Error processing response:", error);
                        data.correct = NaN; // Assign NaN in case of any error
                    }
                    const end_time = performance.now(); // Record end time
                    const duration = Math.round(end_time - start_time_resp); // Calculate duration
                    data.RT = duration; // Save to trial data

                    // for staircase
                    data.currThreshold = invNormalizeVals(quest.threshold); //quest.threshold*196+4;
                    // const correct = stimulusLevel > 40; // Example rule for correct response
                    // data.correct = correct; // Save response
                    // data.stimulusLevel = stimulusLevel; // Save stimulus level
                    data.revCount = quest.countReversal()
                    data.pdf = quest.pdf
                    data.likelihood = quest.addResponse(data.currThreshold, data.correct)
                },
                trial_duration: 5000
            };
            timeline.push(respPage)

            if ((jj%7 == 0) && (jj != 0)) {
                timeline.push(breakPage)
            }

        
        } 

    endPage = {
            type: jsPsychSurveyHtmlForm,
            // stimulus:'<div class="center-stimulus"> Welcome!</div>',
            // stimulus: '<p style="text-align: center;">Welcome to this study!<br>Here you will watch several short animations and answer questions about them.</p>',
            html: '<p style="text-align: center; width: 400px">Great job!<br> When you are ready, press continue to go to the next page for Part 3.</p>',
            on_load: function() {
                const buttons = document.querySelectorAll('.jspsych-btn');
                buttons.forEach(button => {
                    button.style.display = 'block';
                    button.style.margin = '0 auto';
                });

                const data = jsPsych.data.get().csv();
                // Save the data as a CSV file
                saveData("experiment_data_part2.csv", data);
                // jsPsych.data.displayData('csv');
            }
        };
    timeline.push(endPage)

    var goodbye = { // future studies - move window.location to on_finish (this still doesn't explain why data doesn't save though - because it did for some peopel
            type: jsPsychHtmlKeyboardResponse,
            stimulus: 'Going to part 3..',
            on_load: function() {
                window.location = 'https://rvar-page.github.io/jspsych-uncertainty-experiment/part3';
                //CHANGE THIS FOR NEW STUDIES!!!!
            }
        };
    timeline.push(goodbye);


    jsPsych.run(timeline);

    </script>

</body>

</html>