<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Random Dots Experiment</title>

    <!-- Include jsPsych CDN -->
    <script src="https://unpkg.com/jspsych@8.0.3"></script>
    <script src="https://unpkg.com/@jspsych/plugin-html-keyboard-response@2.0.0"></script>
    <script src="https://unpkg.com/@jspsych/plugin-html-button-response@2.0.0"></script>
    <script src="https://unpkg.com/@jspsych/plugin-html-slider-response@2.0.0"></script>
    <!--<script src="https://cdn.jsdelivr.net/npm/jspsych@7.2.1/jspsych.js"></script> -->
    <script src="https://unpkg.com/@jspsych/plugin-survey-html-form@2.0.0"></script>
    <link rel="stylesheet" href="https://unpkg.com/@jspsych/css@8.0.0">


    <!-- Styling for the dots -->
    <style>
        .dot {
            width: 10px;
            height: 10px;
            background-color: black;
            border-radius: 50%;
            position: absolute;
            will-change: transform;
            /* Hint to the browser for GPU acceleration */
        }

        /* Center the dot container with adjustments */
        #dot-container {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 40vw;
            /* 50vw Covers 50% of the viewport width */
            height: 70vh;
            /* 50vh Covers 50% of the viewport height */
            transform: translate(-50%, 0%);
            /* transform: translate(-50%, 0%);  */
            /* Perfectly centers the container */
            overflow: visible;
            background-color: lightgray;
            /* Optional: Adds background for visibility */
            border: 1px solid black;
            /* Optional: Adds a border for visibility */
        }

        /* (-50%, 50%); (-25%, 25%);  */
        /* A: (0%, -50%)*/

        .center-stimulus {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        body {
            font-size: 24px;
            /* Adjust the size as needed */
        }

        /* Target jsPsych-specific elements for finer control */
        .jspsych-content,
        .jspsych-display-element {
            font-size: 24px;
            /* Adjust font size for jsPsych content */
        }

        .jspsych-btn {
            font-size: 24px;
            /* Adjust button font size */
        }

        body, .jspsych-content, .jspsych-display-element, .jspsych-btn, .jspsych-html-slider-response-container span {
                font-family: 'Arial', 'Helvetica', sans-serif;
        }
    </style>
</head>

<body>

    <script>
        // yet to fix - the first frame is blank possibly because of some async issues

        const centerStyle = `
        <style>
            html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            }
            .jspsych-content-wrapper {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            width: 100%;
            }
        </style>
        `;
        // Add the CSS to the document head and run the trial
        document.head.insertAdjacentHTML("beforeend", centerStyle);

        const jsPsych = initJsPsych({
            // show_progress_bar: true,
            on_finish: function () {
                // const data = jsPsych.data.get().csv();
                // // // Save the data as a CSV file
                // saveData("experiment_data_part1.csv", data);
                // jsPsych.data.displayData('csv');

                // const experimentData = jsPsych.data.get().values();


            }
        });

        console.log('jsPsych initialized');

        // Set parameters
        const dotDur = 4; // in frames, 133ms close to 120ms
        const NdotsPerActor = 13;
        const Ndots = NdotsPerActor * 2;

        const noiseSpread = 200; // spread of noise from center

        const control_ = "LRswapped"; // Options: 'inverted', 'LRflipped' (agents look away), 'scr', 'LRswapped' (agent positions swapped, still social)

        const Nframes = 100;
        const good_female = true; // only one of these should be true
        const good_male = false;
        const good_both = false;

        if (good_female) {
            console.log('here')

            var stimList = ['come_closer', 'get_down', 'go_overthere',
                'I_am_angry', 'I_am_happy', 'look_ceiling', 'look_floor',
                'pick_up', 'stand_up']

            resp_choices_p1 = ['come closer', 'get down', 'go over there',
                'I am angry', 'I am happy', 'look at<br>the ceiling', 'look at<br>the floor',
                'pick it up', 'stand up']

            resp_choices_p2 = ['comes closer',
                'squats down',
                'goes in the<br>indicated direction',
                'asks the other<br>person to<br>calm down',
                'expresses joy for<br>other person',
                'turns to look<br>at the ceiling',
                'bends to look<br>at something<br>on the floor',
                'picks up<br>something',
                'stands up']
        }

        if (good_male) {
            var stimList = ['come_closer', 'go_overthere', 'I_am_happy',
                'look_ceiling', 'look_floor', 'move_over', 'no', 'pick_up',
                'sit_down', 'which_one']

            resp_choices_p1 = ['come closer', 'go over there', 'I am happy',
                'look at<br>the ceiling', 'look at<br>the floor', 'move over', 'no!', 'pick it up',
                'sit down', 'stand up']

            resp_choices_p2 = ['comes closer',
                'goes in the<br>indicated direction',
                'expresses joy for<br>other person',
                'turns to look<br>at the ceiling',
                'bends to look<br>at the floor',
                'moves over',
                'retreats',
                'picks up<br>something',
                'sits down',
                'takes an<br>object']
        }

        if (good_both) {
            var stimList = ['come_closer', 'go_overthere',
                'look_ceiling', 'look_floor', 'pick_up']

            resp_choices_p1 = ['come closer', 'go over there',
                'look at<br>the ceiling', 'look at<br>the floor', 'pick it up']

            resp_choices_p2 = ['comes closer',
                'goes in the<br>indicated direction',
                'turns to look<br>at the ceiling',
                'bends to look<br>at the floor',
                'picks object<br>up']
        }


        var blockSeq;
        if (Math.random() < 0.5) {
            blockSeq = [1, 2, 1, 2, 1, 2, 1, 2];
        } else {
            blockSeq = [2, 1, 2, 1, 2, 1, 2, 1];
        }
        console.log('blockSeq',blockSeq)
        const repeatCount = stimList.length - 1; //12-1;

        stimList = stimList.flatMap(row => Array(repeatCount).fill(row));
        console.log('stimList', stimList)

        let prompt;

        const resp_choices_alltrials_response1 = [];
        // Iterate over each choice
        resp_choices_p1.forEach((rowChoice, rowIndex) => {
            resp_choices_p1.forEach((colChoice, colIndex) => {
                if (rowIndex !== colIndex) {
                    if (Math.random() < 0.5) {
                        resp_choices_alltrials_response1.push([rowChoice, colChoice]); // Original order
                    } else {
                        resp_choices_alltrials_response1.push([colChoice, rowChoice]); // Reversed order
                    }
                }
            });
        });
        console.log('resp_choices_alltrials_response1', resp_choices_alltrials_response1);

        const resp_choices_alltrials_response2 = [];
        // Iterate over each choice
        resp_choices_p2.forEach((rowChoice, rowIndex) => {
            resp_choices_p2.forEach((colChoice, colIndex) => {
                if (rowIndex !== colIndex) {
                    if (Math.random() < 0.5) {
                        resp_choices_alltrials_response2.push([rowChoice, colChoice]); // Original order
                    } else {
                        resp_choices_alltrials_response2.push([colChoice, rowChoice]); // Reversed order
                    }
                }
            });
        });
        console.log('resp_choices_alltrials_response2', resp_choices_alltrials_response2);

        // Generate a series from 0 to len(stimList) - 1
        const series = Array.from({ length: stimList.length }, (_, index) => index);

        // Function to shuffle the series array
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        // Scramble the series
        const trialSeq = shuffleArray(series); // to make sure stimulus and response sequences are from the same rows
        const Nstims = stimList.length;
        const Ntrials = stimList.length;//8;//8;

        const thresh = 100;
        const diff = 15;
        const NoiseLevels = [thresh - 2 * diff, thresh - diff, thresh + diff, thresh + 2 * diff]; // loaded from NoiseLevels.mat
        // const NoiseLevels = [16, 48, 80, 112]; // loaded from NoiseLevels.mat
        const NtrialsPerNoiselevel = Math.round(Ntrials / NoiseLevels.length); // 64/4 = 16
        const NnoiseDotsAll = jsPsych.randomization.shuffle(
            NoiseLevels.flatMap(level => Array(NtrialsPerNoiselevel).fill(level))
        ); // shuffled array with 64 trials specifying how much noise each trial should have

        const NtrialsPerStim = Math.round(Ntrials / stimList.length); // 64/8 = 16
        const stimAll = stimList;
        console.log('stimAll', stimAll)

        console.log('NnoiseDotsAll:', NnoiseDotsAll)

        const NstimDots = 16; // number of stimulus dots
        const NdotsToShow = NstimDots;

        const setSize = NdotsToShow / dotDur; // number of dots changed per frame
        // console.log("Set Size:", setSize); 

        // Set bounds for dot sets
        const setBounds = Array.from({ length: dotDur + 1 }, (_, i) => i * (NdotsToShow / dotDur));
        // console.log("Set Bounds:", setBounds);

        const Nsets = setBounds.length - 1; // number of sets
        // console.log("Number of Sets:", Nsets);

        // Initialize arrays
        let selTemp = Array(NdotsToShow).fill(null);
        let selStim = [];
        let rows,cols,stimx,stimz,possCoordsNoisex,possCoordsNoisez,offsetx,offsetz,timeWindow,swapXZ,flipX,flipZ,sel,f,s,whichDots,range,sampled,ind,noisex,noisez,d,container,buttons;
        let  dataA, dataB, linesA, linesB, headerA, headerB, textA, textB,indA, indB, parts, shift,scale,min,max,labels;
        let totFrames,columnsA,columnsB;
        
        f = 0;
        // Helper function to sample from an array
        function sampleFrom(N, toChooseFrom) {
            // Ensure toChooseFrom is a flat array
            if (!Array.isArray(toChooseFrom)) {
                throw new Error("toChooseFrom must be an array");
            }

            // Shuffle the array
            function shuffle(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                return array;
            }

            if (N < toChooseFrom.length) { // WHY IS 
                // If N is smaller than the length of toChooseFrom, shuffle and return the first N elements
                const sorted = shuffle([...toChooseFrom]); // Clone the array before shuffling
                return sorted.slice(0, N);
            } else {
                // If N is larger, repeat toChooseFrom enough times, shuffle, and return the first N elements
                const repeated = Array.from({ length: Math.ceil(N / toChooseFrom.length) }, () => toChooseFrom).flat();
                const sorted = shuffle(repeated);
                return sorted.slice(0, N);
            }
        }

        function getDistrInfo(array) {
            // Flatten the 2D array into a 1D array
            const flattened = array.flat();

            // Sort the 1D array in ascending order
            const sorted = flattened.sort((a, b) => a - b);

            const length = sorted.length;

            // Helper function to find the value at a specific percentile
            function getPercentile(sortedArray, percentile) {
                const index = (percentile / 100) * (sortedArray.length - 1);
                const lower = Math.floor(index);
                const upper = Math.ceil(index);
                const weight = index - lower;
                return sortedArray[lower] * (1 - weight) + sortedArray[upper] * weight;
            }

            // Calculate Q1 (25th percentile), median (50th percentile), and Q3 (75th percentile)
            const q1 = getPercentile(sorted, 25);
            const median = getPercentile(sorted, 50);
            const q3 = getPercentile(sorted, 75);

            console.log('q1, median, q3 :', q1, median, q3)

            return { q1, median, q3 };
        }

        // Generate stimulus dots to be presented (can be scaled up to mutiple trials and doesn't depend on performance,
        // hence outside on_load)
        while (f <= Nframes + Nsets) {
            for (let s = 0; s < Nsets; s++) {
                const whichDots = Array.from({ length: setBounds[s + 1] - setBounds[s] }, (_, i) => setBounds[s] + i);
                // console.log("Which Dots:", whichDots);

                const availableDots = Array.from({ length: Ndots }, (_, i) => i + 1).filter(dot => !selTemp.includes(dot));
                selTemp.splice(setBounds[s], whichDots.length, ...sampleFrom(setSize, availableDots));
                // console.log('typeof selTemp', typeof selTemp);
                // selTemp.sort((a, b) => a - b); // sort selTemp (for later tests) --> somehow works weirdly for the 1st 4 dots so scrapped it.
                selStim.push([...selTemp]);
                f++;
            }
        }

        // Remove initial frames
        selStim = selStim.slice(Nsets, Nframes + Nsets);

        // Determine stimulus order
        const stimTrialOrder = Array.from({ length: Ntrials }, (_, i) => i % Nstims).sort(() => 0.5 - Math.random());

        function createStimulusClip(stimx, stimz, noisex, noisez, NnoiseDots, numFrames = 100, numDots = 16) {
            // function to present the stimuli
            console.log('inside createStimulusClip function')
            // Create the dot container
            const container = document.createElement("div");
            container.id = "dot-container";
            container.style.position = "relative";
            container.style.overflow = "visible"; // Ensure dots stay inside container

            
            // Create a reusable dot array
            const dots = [];
            // const container = document.querySelector("#dot-container");
            // const dots = Array.from(container.children);
            for (let i = 0; i < numDots + NnoiseDots + 1; i++) {
                // for (let i = 0; i < numDots; i++) {
                const dot = document.createElement("div");
                dot.className = "dot";
                dot.style.position = "absolute";
                dot.style.width = "5px";//"10px";
                dot.style.height = "5px";//"10px";
                dot.style.backgroundColor = "black";
                dot.style.borderRadius = "50%";

                // Initialize all dots with a default position off-screen
                dot.style.left = "-9999px";
                dot.style.bottom = "-9999px";

                container.appendChild(dot);
                dots.push(dot);
            }

            // Update only positions
            // dots.forEach((dot, i) => {
            //     dot.style.transform = `translate(${noisex[currentFrame][i]}px, ${noisez[currentFrame][i]}px)`;
            // });

            // Animation loop
            let currentFrame = 0;
            const interval = setInterval(() => {
                // if (currentFrame >= 1) { // for debugging
                if (currentFrame >= numFrames) {
                    // if (currentFrame >= 1) {
                    clearInterval(interval); // End animation
                    return;
                }
                // console.log(`Current Frame: ${currentFrame}, stimx:`, stimx[currentFrame], 'stimz:', stimz[currentFrame]);

                // Update dot positions for the current frame
                //present stimdots
                for (let i = 0; i < numDots; i++) {
                    dots[i].style.backgroundColor = 'black';//'white';// for debugging. "black";
                    dots[i].style.left = stimx[currentFrame][i] !== undefined
                        ? `${stimx[currentFrame][i]}%`
                        : (() => {
                            console.error(`Undefined value in stimx: Frame ${currentFrame}, Dot ${i}`);
                            return '50%';
                        })();

                    dots[i].style.bottom = stimz[currentFrame][i] !== undefined
                        ? `${stimz[currentFrame][i]}%`
                        : (() => {
                            console.error(`Undefined value in stimz: Frame ${currentFrame}, Dot ${i}`);
                            return '50%';
                        })();
                }

                currentFrame++;
            }, 33); //, 100); // , 33);   ~30 fps

            dots.forEach((dot, i) => {
                if (dot.style.left === "-9999px" || dot.style.bottom === "-9999px") {
                    console.warn(`Dot ${i} has an uninitialized position at frame ${currentFrame}.`);
                    dot.style.backgroundColor = "red";
                } else {
                    console.log(
                        `Frame ${currentFrame}, Dot ${i}: left=${dot.style.left}, bottom=${dot.style.bottom}`
                    );
                }
            });
            return container;
        }

        function getDimensions(array) {
            const nrows_func = array.length; // Number of rows
            console.log('in func', nrows_func)
            const ncols_func = array[0]?.length || 0; // Number of columns in the first row, or 0 if empty
            console.log('in func', ncols_func)
            // return { nrows_func, ncols_func };
        }

        // Function to transpose a 2D array
        function transpose(array) {
            return array[0].map((_, colIndex) => array.map(row => row[colIndex]));
        }

        function linspace(start, end, num) {
            const step = (end - start) / (num - 1); // Calculate step size
            return Array.from({ length: num }, (_, i) => start + i * step);
        }

        function saveData(filename, data) {
            const blob = new Blob([data], { type: "text/plain" }); // Create a Blob object with the data
            const link = document.createElement("a"); // Create an invisible <a> element
            link.href = window.URL.createObjectURL(blob); // Create a URL for the Blob
            link.download = filename; // Set the download filename
            document.body.appendChild(link); // Append the <a> to the DOM
            link.click(); // Trigger a click to start the download
            document.body.removeChild(link); // Remove the <a> after download
        }

        let dotTrial, respPage, confPage, start_time_conf,resp_choices;
        let timeline = [];

        // Prolific Id
        timeline.push({
            type: jsPsychSurveyHtmlForm,
            preamble: '<p>Please enter your <strong>24-character</strong> Prolific ID here<br>(If piloting, please enter your name or initials)</p>',
            html: `
                <p align="center"> 
                    <input id="prolific_ID_start" 
                        class="textbox" 
                        type="text" 
                        style="width: 70%; height: 20px; font-size: 24px; padding: 5px;" 
                        name="prolific_ID_name_start" 
                        required /> 
                    <br>
                </p>
            `,
            on_load: function () {
                const buttons = document.querySelectorAll('.jspsych-btn');
                buttons.forEach(button => {
                    button.style.display = 'block';
                    button.style.margin = '0 auto';
                });
            },
            on_finish: function (data) {
                const formData = jsPsych.data.getLastTrialData().values()[0].response['prolific_ID_name_start'];
                console.log('Form Data:', formData); // Check collected data
                data.prolific_id = formData || ''; // Save the Prolific ID
            }
        });

        introPage = {
            type: jsPsychSurveyHtmlForm,
            html: '<p style="text-align: center; width: 600px"><br>In this study, you will watch short animation clips that depict two interacting people as viewed from the side. In each clip, person 2 will react to person 1’s action. <br><br>After each clip, you will be asked a question about either: <br>(1) the action of person 1 (the initiator) or <br>(2) the reaction of person 2 (the responder).<br><br>There are no right or wrong answers here!<br><br>Next, you will see a sample animation clip.<br><br>',
            on_load: function () {
                const buttons = document.querySelectorAll('.jspsych-btn');
                buttons.forEach(button => {
                    button.style.display = 'block';
                    button.style.margin = '0 auto';
                });
            }
        }
        timeline.push(introPage)

        const twosexes = ['M', 'F'];
        let sex,stimFileA,stimFileB;
        const NnoiseDots = 1 // when developing code

        dotTrialDemo = {
            type: jsPsychHtmlKeyboardResponse,
            stimulus: function () {
                return `<div id="dot-container" style="position: relative; width: 40vw; height: 70vh;"></div>`;
            },
            choices: 'NO_KEYS',
            on_load: async function () {
                console.log('demo animation')
                // for each trial, first read the stim file, shift and scale values, concat across agents etc. (only stim)
                // stim stuff begins
                let demoStim = 'this_tall'
                if (good_both)   {sex = twosexes[Math.floor(Math.random() * twosexes.length)];}
                if (good_male)   {sex = 'M';}
                if (good_female) {sex = 'F';}
                if (Math.random() < 0.5) {curr_stim = [`${demoStim}_${sex}_A.txt`,           `${demoStim}_${sex}_B.txt`]; }
                else                     {curr_stim = [`${demoStim}_${sex}_B_LRswapped.txt`, `${demoStim}_${sex}_A_LRswapped.txt`];}
                console.log('curr_stim', curr_stim)
                // stimFileA = `stims/${curr_stim[0]}`;
                // stimFileB = `stims/${curr_stim[1]}`;

                stimFileA = `https://rvar-page.github.io/jspsych-uncertainty-experiment/part1/stims/${curr_stim[0]}`;
                stimFileB = `https://rvar-page.github.io/jspsych-uncertainty-experiment/part1/stims/${curr_stim[1]}`;


                console.log("File path for A:", stimFileA);
                console.log("File path for B:", stimFileB);

                dataA = await fetch(stimFileA); //await fetch('./come_closer_F_A.txt');
                dataB = await fetch(stimFileB); //await fetch('./come_closer_F_A.txt');

                textA = await dataA.text();
                textB = await dataB.text();

                // console.log('dataA:', dataA, 'dataB:', dataB)

                linesA = textA.trim().split('\n');// Split the data into lines and skip the first line (header)
                linesB = textB.trim().split('\n');// Split the data into lines and skip the first line (header)

                // Handle header if i = 0
                headerA = linesA[0]; // Always take the first line as the header
                headerB = linesB[0]; // Always take the first line as the header
                console.log('headerA', headerA)
                totFrames = headerA.match(/frames\s*=\s*(\d+)/)[1]; // tot frames is useful to reshape the array
                console.log('totFrames', totFrames)
                bodyA = linesA.slice(1);
                bodyB = linesB.slice(1);
                columnsA = bodyA.map(line => {
                    parts = line.trim().split(/\s+/); // Split line by whitespace
                    return [parseFloat(parts[0]), parseFloat(parts[2])]; // Extract columns 0 and 2 as numbers
                });
                const columnsB = bodyB.map(line => {
                    parts = line.trim().split(/\s+/); // Split line by whitespace
                    return [parseFloat(parts[0]), parseFloat(parts[2])]; // Extract columns 0 and 2 as numbers
                });

                // Separate columns
                ax = columnsA.map(row => row[0]); // Extract first column
                az = columnsA.map(row => row[1]); // Extract second column

                bx = columnsB.map(row => row[0]); // Extract first column
                bz = columnsB.map(row => row[1]); // Extract second column

                /* shift and scale! */
                shift = 50;
                scale = 20;
                // Find the minimum and maximum values
                min = Math.min(...ax);
                max = Math.max(...ax);
                // Center and normalize the array
                ax = ax.map(num => (num - min) / (max - min));
                ax = ax.map(num => num * scale + shift);

                min = Math.min(...ax);
                max = Math.max(...ax);

                shift = 30//-20;
                // Find the minimum and maximum values
                min = Math.min(...bx);
                max = Math.max(...bx);
                bx = bx.map(num => (num - min) / (max - min));
                bx = bx.map(num => num * scale + shift);

                min = Math.min(...bx);
                max = Math.max(...bx);

                shift = 20//-30; // same shift and scale for both 
                scale = 60;
                // vertical
                // Find the minimum and maximum values
                min = Math.min(...az);
                max = Math.max(...az);
                // Center and normalize the array
                az = az.map(num => (num - min) / (max - min));
                az = az.map(num => num * scale + shift);

                min = Math.min(...az);
                max = Math.max(...az);

                // // Find the minimum and maximum values
                min = Math.min(...bz);
                max = Math.max(...bz);
                // Center and normalize the array
                bz = bz.map(num => (num - min) / (max - min));
                bz = bz.map(num => num * scale + shift);

                min = Math.min(...bz);
                max = Math.max(...bz);

                rows = totFrames;
                cols = 13;
                ax = Array.from({ length: rows }, (_, i) =>
                    ax.slice(i * cols, (i + 1) * cols)
                );
                az = Array.from({ length: rows }, (_, i) =>
                    az.slice(i * cols, (i + 1) * cols)
                );

                bx = Array.from({ length: rows }, (_, i) =>
                    bx.slice(i * cols, (i + 1) * cols)
                );
                bz = Array.from({ length: rows }, (_, i) =>
                    bz.slice(i * cols, (i + 1) * cols)
                );

                stimx = [];
                stimz = [];
                ax_bx = ax.map((row, i) => row.concat(bx[i]));  //ax.concat(bx);
                az_bz = az.map((row, i) => row.concat(bz[i]));  //ax.concat(bx);
                min = Math.min(...ax_bx.flat());
                max = Math.max(...ax_bx.flat());
                min = Math.min(...az_bz.flat());
                max = Math.max(...az_bz.flat());
                // end of stim stuff

                // start of noise stuff

                NdotsToShowNoise = NnoiseDots;
                setBoundsNoise = linspace(0, NdotsToShowNoise, dotDur + 1) // start and stop of each quarter.
                setBoundsNoise = setBoundsNoise.map(num => Math.ceil(num));

                
                possCoordsNoisex = transpose(ax_bx);
                possCoordsNoisez = transpose(az_bz);

                // Initialize arrays (which are later combined to generate noise) with 0
                offsetx = Array.from({ length: NnoiseDots }, () =>
                    Array(Nframes).fill(0)
                );
                offsetz = Array.from({ length: NnoiseDots }, () =>
                    Array(Nframes).fill(0)
                );
                timeWindow = Array.from({ length: NnoiseDots }, () =>
                    Array(Nframes).fill(0)
                );
                swapXZ = Array.from({ length: NnoiseDots }, () =>
                    Array(Nframes).fill(0)
                );
                flipX = Array.from({ length: NnoiseDots }, () =>
                    Array(Nframes).fill(1)
                );
                flipZ = Array.from({ length: NnoiseDots }, () =>
                    Array(Nframes).fill(1)
                );
                console.log('offsetx[0][0]:', offsetx[0][0]) // sanity check. should be 0

                // Initialize `sel` as a 2D array with NnoiseDots rows and (Nframes + Nsets) columns, filled with NaN
                sel = Array.from({ length: NnoiseDots }, () =>
                    Array(Nframes + Nsets).fill(NaN)
                );
                // Select and transform dots
                f = 0; // Frame counter
                
                while (f <= Nframes + Nsets) { // repmat not working!!!!!
                    for (s = 0; s < Nsets; s++) { // for each set of NnoiseDots/4 dots
                        whichDots = Array.from(
                            { length: setBoundsNoise[s + 1] - setBoundsNoise[s] },
                            (_, i) => setBoundsNoise[s] + i
                        ); // should be something like 0-12, 12-24 etc
                        range = Array.from({ length: Ndots }, (_, i) => i); // 1:Ndots (1:26) --> inds from which to select stimuli
                        sampled = sampleFrom(Math.ceil(NnoiseDots / dotDur), range);  // sample 16 dots
                        // edit a quarter of dots
                        samp = -1;
                        whichDots.forEach((dot) => { // for each of the 12 dots (48 noisedots version). e.g. dot goes from 36 to 47
                            samp++;
                            // assign temporary values to each dot within the set
                            main_dot_ind = sampled[samp] //selTemp[dot]; // sel has the dot number (wrt the main stim set) 
                            // for each of the 48 dots and Nframes+4 frames
                            offsetxTemp_ = (Math.random() - 0.5) * noiseSpread;
                            offsetzTemp_ = (Math.random() - 0.5) * noiseSpread;
                            timeWindowTemp_ = Math.floor(Math.random() * (Nframes - 3));
                            swapXZTemp_ = Math.round(Math.random());
                            flipXTemp_ = Math.random() < 0.5 ? -1 : 1;
                            flipZTemp_ = Math.random() < 0.5 ? -1 : 1;
                            
                            for (ind = 0; ind < 4; ind++) { // repmat in matlab
                                sel[dot][f + ind] = main_dot_ind
                                offsetx[dot][f + ind] = offsetxTemp_ //offsetxTemp[dot]; // Random x-offset
                                offsetz[dot][f + ind] = offsetzTemp_ //offsetzTemp[dot]; // Random z-offset
                                timeWindow[dot][f + ind] = timeWindowTemp_ + ind; //timeWindowTemp[dot]+ind;
                                swapXZ[dot][f + ind] = swapXZTemp_; // swapXZTemp[dot];
                                flipX[dot][f + ind] = flipXTemp_; //flipXTemp[dot];
                                flipZ[dot][f + ind] = flipZTemp_; //flipZTemp[dot];
                            }
                        });
                        f++;
                    }
                }
                sel = sel.map(row => row.slice(Nsets, Nframes + Nsets));
                offsetx = offsetx.map(row => row.slice(Nsets, Nframes + Nsets));
                offsetz = offsetz.map(row => row.slice(Nsets, Nframes + Nsets));

                 noisex = Array.from({ length: Nframes }, () =>
                    Array(NnoiseDots).fill(0)
                );
                noisez = Array.from({ length: Nframes }, () =>
                    Array(NnoiseDots).fill(0)
                );

                for (f = 0; f < Nframes; f++) {
                    for (d = 0; d < NnoiseDots; d++) {

                        if (swapXZ[d][f]) {
                            // Perform coordinate swap and offset adjustment
                            noisex[f][d] =
                                flipX[d][f] *
                                possCoordsNoisez[sel[d][f]][timeWindow[d][f]] +
                                offsetx[d][timeWindow[d][f]]; // offsetx[sel[d][f]][timeWindow[d][f]];  just need 'd' here. E.g if the dot is 26 in the actual dot array, for the offset, it' still a value between 1 and Nnoisedots
                            noisez[f][d] =
                                flipZ[d][f] *
                                possCoordsNoisex[sel[d][f]][timeWindow[d][f]] +
                                offsetz[d][timeWindow[d][f]]; // offsetz[sel[d][f]][timeWindow[d][f]];
                        }
                        else {
                            // Standard coordinate adjustment
                            noisex[f][d] =
                                flipX[d][f] *
                                possCoordsNoisex[sel[d][f]][timeWindow[d][f]] +
                                offsetx[d][timeWindow[d][f]]; //offsetx[sel[d][f]][timeWindow[d][f]];
                            noisez[f][d] =
                                flipZ[d][f] *
                                possCoordsNoisez[sel[d][f]][timeWindow[d][f]] +
                                offsetz[d][timeWindow[d][f]]; // //offsetz[sel[d][f]][timeWindow[d][f]];
                        }
                    }
                }
                // console.log('noisex', noisex)

                /* shift and scale noise!! */
                shift = 0;
                scale = 100;
                // Find the minimum and maximum values
                min = Math.min(...noisex.flat());
                max = Math.max(...noisex.flat());
                // console.log('before: noisex: min', min, ',max', max) // there is a bug already before!!
                // Center and normalize the array
                noisex = noisex.map(row => row.map(num => (num - min) / (max - min))); //noisex.map(num => (num - min) / (max - min));
                noisex = noisex.map(row => row.map(num => num * scale + shift));
                min = Math.min(...noisex.flat());
                max = Math.max(...noisex.flat());
                // console.log('noisex after : min', min, ',max', max)


                shift = 0//-30; // same shift and scale for both 
                scale = 100 //100;
                // vertical
                // Find the minimum and maximum values
                min = Math.min(...noisez.flat());
                max = Math.max(...noisez.flat());

                // Center and normalize the array
                noisez = noisez.map(row => row.map(num => (num - min) / (max - min)));
                noisez = noisez.map(row => row.map(num => num * scale + shift));

                min = Math.min(...noisez.flat());
                max = Math.max(...noisez.flat());
                // end of noise stuff

                for (f = 0; f < Nframes; f++) {
                    stimx.push(
                        selStim[f].map(index => {
                            if (ax_bx[f][index - 1] === undefined) {
                                console.error(`Undefined in stimx at frame ${f}, index ${index - 1}`);
                            }
                            return ax_bx[f][index - 1];
                        })
                    );

                    stimz.push(
                        selStim[f].map(index => {
                            if (az_bz[f][index - 1] === undefined) {
                                console.error(`Undefined in stimz at frame ${f}, index ${index - 1}`);
                            }
                            return az_bz[f][index - 1];
                        })
                    );
                }
                min = Math.min(...stimx.flat());
                max = Math.max(...stimx.flat());
                // console.log('stimx: min', min, ',max', max)

                min = Math.min(...stimz.flat());
                max = Math.max(...stimz.flat());
                // console.log('stimz: min', min, ',max', max)

                min = Math.min(...noisex.flat());
                max = Math.max(...noisez.flat());
                // console.log('noisex: min', min, ',max', max)

                min = Math.min(...noisex.flat());
                max = Math.max(...noisez.flat());
                // console.log('noisez: min', min, ',max', max)                

                container = document.getElementById("dot-container");
                if (container) {
                    container.replaceWith(createStimulusClip(stimx, stimz, noisex, noisez, NnoiseDots, Nframes, NstimDots));
                } else {
                    console.error("Dot container not found!");
                }
            },
            trial_duration: 3200 // End trial after 1 second (10 sets * .1 seconds)
        };
        timeline.push(dotTrialDemo);

        const respPageIntro = {
            type: jsPsychHtmlButtonResponse,
            stimulus: `
            <div style="width: 600px; margin: auto; text-align: center; font-family: sans-serif; font-size: 24px;">
                <p style="text-align: center; margin: 20px auto; max-width: 600px; line-height: 1.5;">
                    These will be the 2 types of questions:
                </p>

                <!-- Slider 1 -->
                <div style="margin-bottom: 40px; max-width: 600px; margin: auto;">
                    <p style="text-align: center; margin-bottom: 10px;">
                        <br>Person 1 (initiator) said:
                    </p>
                    <div style="position: relative; width: 400px; margin: auto;">
                        <input type="range" id="slider1" min="0" max="100" value="50" step="1" 
                        style="width: 100%; margin: 10px 0;">
                        <div style="display: flex; justify-content: space-between; position: absolute; top: 35px; width: 100%;">
                            <span style="position: absolute; left: 0; transform: translateX(-50%);">action 1</span>
                            <span style="position: absolute; right: 0; transform: translateX(50%);">action 2</span>
                        </div>
                    </div>
                </div>

                <!-- Slider 2 -->
                <div style="margin-bottom: 40px; max-width: 600px; margin: auto;">
                    <p style="text-align: center; margin-bottom: 10px;">
                        <br>or<br><br>Person 2 (responder):
                    </p>
                    <div style="position: relative; width: 400px; margin: auto;">
                        <input type="range" id="slider2" min="0" max="100" value="50" step="1" 
                        style="width: 100%; margin: 10px 0;">
                        <div style="display: flex; justify-content: space-between; position: absolute; top: 35px; width: 100%;">
                            <span style="position: absolute; left: 0; transform: translateX(-50%);">had<br>reaction 1</span>
                            <span style="position: absolute; right: 0; transform: translateX(50%);">had<br>reaction 2</span>
                        </div>
                    </div>
                    <p style="text-align: center; margin: 20px auto; max-width: 600px; line-height: 1.5;">
                        <br><br>You should click on (or click-and-drag) the slider ONCE to indicate which action/reaction you just saw and how confident you feel about it.<br>Click closer to an action/reaction label if you feel confident about it, and further from the edges depending on your confidence.
                    </p>
                </div>
            </div>`,
            choices: ['Continue'],
            on_load: function() {
                const slider1 = document.getElementById('slider1');
                const slider2 = document.getElementById('slider2');
                const slider1Value = document.getElementById('slider1Value');
                const slider2Value = document.getElementById('slider2Value');

                slider1.oninput = () => {
                slider1Value.textContent = `Value: ${slider1.value}`;
                };
                slider2.oninput = () => {
                slider2Value.textContent = `Value: ${slider2.value}`;
                };

                buttons = document.querySelectorAll('.jspsych-btn');
                buttons.forEach(button => {
                    button.style.display = 'block';
                    button.style.margin = '0 auto';
                });
            },
            };
        timeline.push(respPageIntro);

        timeline.push({
            type: jsPsychSurveyHtmlForm,
            html: '<p style="text-align: center; width: 400px"><br>Let us watch the animation clip again on the next page. Pay attention.<br><br>',
            on_load: function () {
                buttons = document.querySelectorAll('.jspsych-btn');
                buttons.forEach(button => {
                    button.style.display = 'block';
                    button.style.margin = '0 auto';
                });
            }
        });
        timeline.push(dotTrialDemo);

        if (Math.random() > 0.5) {
            resp_page_choices_action = ['This tall?', 'Sit down'];
        }else{
            resp_page_choices_action = [ 'Sit down', 'This tall?']
        }
        let slider,sliderContainer;
        respPageDemo1 = {
            type: jsPsychHtmlSliderResponse,
            stimulus: '<p style="text-align: center; width: 600px">Click on the slider to indicate both what you saw and your confidence. Place it closer to an action if you are confident about it, or further from the edges if you are unsure.<br><br>Person 1 (initiator) said: </p>',
            labels: resp_page_choices_action,
            prompt: '',
            slider_width: 400, // Width of the slider in pixels
            require_movement: true,
            on_load: function () {
                console.log('demo slider response 1')
                jsPsych.data.get().addToLast({ nt: -1, stim: 'None', resp: resp_page_choices_action });

                // Hide the continue button
                const button = document.querySelector('.jspsych-btn');
                // const button = document.querySelector('.jspsych-html-slider-response .jspsych-btn');
                if (button) {
                    button.style.display = 'none';
                }

                sliderContainer = document.querySelector('.jspsych-content');
                sliderContainer.style.display = 'flex';
                sliderContainer.style.flexDirection = 'column';
                sliderContainer.style.alignItems = 'center';
                sliderContainer.style.textAlign = 'center';
                sliderContainer.style.width = '100%'; // Ensure full width
                sliderContainer.style.maxWidth = '600px'; // Limit max width for text
                sliderContainer.style.margin = 'auto'; // Center horizontally
                sliderContainer.style.padding = '10px';

                // Adjust label font size and alignment
                labels = document.querySelectorAll('.jspsych-html-slider-response-container span');
                labels.forEach((label) => {
                    label.style.fontSize = '24px'; // Increase font size
                    label.style.marginTop = '5px'; // Add space below slider for labels
                    label.style.width = 'calc(50% - 10px)'; // Ensure labels fit on either side of slider
                    label.style.textAlign = 'center'; // Center text under slider
                });

                // Increase slider size
                slider = document.querySelector('input[type="range"]');
                slider.style.height = '15px'; // Adjust slider height
                slider.style.width = '400px'; // Ensure it spans the container width
                slider.style.margin = '5px 0'; // Add spacing above and below the slider
                slider.style.padding = '0';

                // Add padding to avoid altering global layout
                sliderContainer.style.padding = '10px';

                // Add event listener to end the trial when slider value changes
                slider.addEventListener('change', () => {
                const response = slider.value;
                    jsPsych.finishTrial({ slider_response: response });
                });
            },
        };
        timeline.push(respPageDemo1)

        if (Math.random() > 0.5) {
            resp_page_choices_reaction = ['indicates<br>that someone<br>is taller', 'sits down'];
        }else{
            resp_page_choices_reaction = ['sits down', 'indicates<br>that someone<br>is taller'];
        }

        respPageDemo2 = {
            type: jsPsychHtmlSliderResponse,
            stimulus: '<p style="text-align: center; width: 600px">Click on the slider to indicate both what you saw and your confidence. Place it closer to an action if you are confident about it, or further from the edges if you are unsure.<br><br>Person 2 (responder): </p>',
            labels: resp_page_choices_reaction,
            prompt: '',
            slider_width: 400, // Width of the slider in pixels
            require_movement: true,
            on_load: function () {
                console.log('demo slider response 2')
                jsPsych.data.get().addToLast({ nt: -1, stim: 'None', resp: resp_page_choices_reaction });

                // Hide the continue button
                const button = document.querySelector('.jspsych-btn');
                // const button = document.querySelector('.jspsych-html-slider-response .jspsych-btn');
                if (button) {
                    button.style.display = 'none';
                }

                sliderContainer = document.querySelector('.jspsych-content');
                sliderContainer.style.display = 'flex';
                sliderContainer.style.flexDirection = 'column';
                sliderContainer.style.alignItems = 'center';
                sliderContainer.style.textAlign = 'center';
                sliderContainer.style.width = '100%'; // Ensure full width
                sliderContainer.style.maxWidth = '600px'; // Limit max width for text
                sliderContainer.style.margin = 'auto'; // Center horizontally
                sliderContainer.style.padding = '10px';

                // Adjust label font size and alignment
                labels = document.querySelectorAll('.jspsych-html-slider-response-container span');
                labels.forEach((label) => {
                    label.style.fontSize = '24px'; // Increase font size
                    label.style.marginTop = '5px'; // Add space below slider for labels
                    label.style.width = 'calc(50% - 10px)'; // Ensure labels fit on either side of slider
                    label.style.textAlign = 'center'; // Center text under slider
                });

                // Increase slider size
                slider = document.querySelector('input[type="range"]');
                slider.style.height = '15px'; // Adjust slider height
                slider.style.width = '400px'; // Ensure it spans the container width
                slider.style.margin = '5px 0'; // Add spacing above and below the slider
                slider.style.padding = '0';

                // Add padding to avoid altering global layout
                sliderContainer.style.padding = '10px';

                // Add event listener to end the trial when slider value changes
                slider.addEventListener('change', () => {
                const response = slider.value;
                    jsPsych.finishTrial({ slider_response: response });
                });
            },
        };
        timeline.push(respPageDemo2)

        main_study_intro = {
            type: jsPsychSurveyHtmlForm,
            html: '<p style="text-align: center; width: 600px"><br>The main study begins now.<br>Keep your eyes on the screen till the next break!<br><br><br>',
            on_load: function () {
                console.log('main task intro')
                buttons = document.querySelectorAll('.jspsych-btn');
                buttons.forEach(button => {
                    button.style.display = 'block';
                    button.style.margin = '0 auto';
                });
            }
        }
        timeline.push(main_study_intro)

        let curr_stim, runIntroPage,b,jj_within_block;
        

        console.log(' blockSeq.length', blockSeq.length)

        const Ntrialsperblock = Ntrials/blockSeq.length;
        console.log('Ntrialsperblock:',Ntrialsperblock)

        for (let b = 0; b < blockSeq.length; b++) { // block loop 
            // let currentBlock = blockSeq[b];
            // console.log('currentBlock',currentBlock)
            // if (currentBlock == 1) {
            if (blockSeq[b] == 1) {
                timeline.push({
                        type: jsPsychSurveyHtmlForm,
                        html: '<p style="text-align: center; width: 600px"><br>Block'+(b+1)+"/8.<br>Identify <b>person 1's</b> action.<br><br>",
                        on_load: function () {
                            buttons = document.querySelectorAll('.jspsych-btn');
                            buttons.forEach(button => {
                                button.style.display = 'block';
                                button.style.margin = '0 auto';
                            });
                        }
                    });
            }
            if (blockSeq[b] == 2) { 
                timeline.push({
                        type: jsPsychSurveyHtmlForm,
                        html: '<p style="text-align: center; width: 600px"><br>Block'+(b+1)+"/8.<br>Identify <b>person 2's</b> reaction.<br><br>",
                        on_load: function () {
                            buttons = document.querySelectorAll('.jspsych-btn');
                            buttons.forEach(button => {
                                button.style.display = 'block';
                                button.style.margin = '0 auto';
                            });
                        }
                    });
            }
            // (runIntroPage)

            const NnoiseDots = 1 // when developing code

            // for (let jj = 0; jj < Ntrials; jj++) {
            for (let jj_within_block = 0; jj_within_block < Ntrialsperblock; jj_within_block++) {
               
                dotTrial = {
                    type: jsPsychHtmlKeyboardResponse,
                    stimulus: function () {
                        return `<div id="dot-container" style="position: relative; width: 40vw; height: 70vh;"></div>`;
                    },
                    choices: 'NO_KEYS',
                    on_load: async function () {
                        jj = 9*b+jj_within_block;
                        console.log('trial jj=', jj)

                        // for each trial, first read the stim file, shift and scale values, concat across agents etc. (only stim)
                        // stim stuff begins
                        console.log('stimTrialOrder', stimTrialOrder)
                        indA = stimTrialOrder[jj - 1];
                        console.log('indA', indA)
                        indB = indA;
                        // const NnoiseDots = NnoiseDotsAll[jj];
                        
                        if (good_both)   { sex = twosexes[Math.floor(Math.random() * twosexes.length)];}
                        if (good_male)   { sex = 'M';}
                        if (good_female) { sex = 'F';}
                        
                        if (Math.random() < 0.5) {curr_stim = [`${stimAll[trialSeq[jj]]}_${sex}_A.txt`, `${stimAll[trialSeq[jj]]}_${sex}_B.txt`]; } 
                        else                     {curr_stim = [`${stimAll[trialSeq[jj]]}_${sex}_B_LRswapped.txt`, `${stimAll[trialSeq[jj]]}_${sex}_A_LRswapped.txt`]; }
                        console.log('curr_stim', curr_stim)

                        stimFileA = `https://rvar-page.github.io/jspsych-uncertainty-experiment/part1/stims/${curr_stim[0]}`;
                        stimFileB = `https://rvar-page.github.io/jspsych-uncertainty-experiment/part1/stims/${curr_stim[1]}`;

                        console.log("File path for A:", stimFileA);
                        console.log("File path for B:", stimFileB);

                        dataA = await fetch(stimFileA);
                        dataB = await fetch(stimFileB);

                        textA = await dataA.text();
                        textB = await dataB.text();

                        // console.log('dataA:', dataA, 'dataB:', dataB)

                        linesA = textA.trim().split('\n');// Split the data into lines and skip the first line (header)
                        linesB = textB.trim().split('\n');// Split the data into lines and skip the first line (header)

                        
                        // Handle header if i = 0
                        // const header = i === 0 ? lines[0] : null;
                        headerA = linesA[0]; // Always take the first line as the header
                        headerB = linesB[0]; // Always take the first line as the header
                        console.log('headerA', headerA)
                        totFrames = headerA.match(/frames\s*=\s*(\d+)/)[1]; // tot frames is useful to reshape the array
                        // console.log('totFrames', totFrames)
                        bodyA = linesA.slice(1);
                        bodyB = linesB.slice(1);
                        columnsA = bodyA.map(line => {
                            parts = line.trim().split(/\s+/); // Split line by whitespace
                            return [parseFloat(parts[0]), parseFloat(parts[2])]; // Extract columns 0 and 2 as numbers
                        });
                        columnsB = bodyB.map(line => {
                             parts = line.trim().split(/\s+/); // Split line by whitespace
                            return [parseFloat(parts[0]), parseFloat(parts[2])]; // Extract columns 0 and 2 as numbers
                        });
                        
                        // Separate columns
                        ax = columnsA.map(row => row[0]); // Extract first column
                        az = columnsA.map(row => row[1]); // Extract second column
                        // console.log('ax',ax,typeof ax[0]); // Output: "number"

                        bx = columnsB.map(row => row[0]); // Extract first column
                        bz = columnsB.map(row => row[1]); // Extract second column
                        // console.log('bx',bx,typeof bx[0]); // Output: "number"

                        
                        /* shift and scale! */
                        shift = 50;
                        scale = 20;
                        // Find the minimum and maximum values
                        min = Math.min(...ax);
                        max = Math.max(...ax);
                        // Center and normalize the array
                        ax = ax.map(num => (num - min) / (max - min));
                        ax = ax.map(num => num * scale + shift);
                        
                        min = Math.min(...ax);
                        max = Math.max(...ax);
                        // console.log('ax: min', min,',max', max)

                        shift = 30//-20;
                        // Find the minimum and maximum values
                        min = Math.min(...bx);
                        max = Math.max(...bx);
                        bx = bx.map(num => (num - min) / (max - min));
                        bx = bx.map(num => num * scale + shift);
                        
                        min = Math.min(...bx);
                        max = Math.max(...bx);
                        
                        shift = 20//-30; // same shift and scale for both 
                        scale = 60;
                        // vertical
                        // Find the minimum and maximum values
                        min = Math.min(...az);
                        max = Math.max(...az);
                        // Center and normalize the array
                        az = az.map(num => (num - min) / (max - min));
                        az = az.map(num => num * scale + shift);

                        min = Math.min(...az);
                        max = Math.max(...az);
                        
                        // // Find the minimum and maximum values
                        min = Math.min(...bz);
                        max = Math.max(...bz);
                        // Center and normalize the array
                        bz = bz.map(num => (num - min) / (max - min));
                        bz = bz.map(num => num * scale + shift);

                        min = Math.min(...bz);
                        max = Math.max(...bz);

                        rows = totFrames;
                        cols = 13;
                        ax = Array.from({ length: rows }, (_, i) =>
                            ax.slice(i * cols, (i + 1) * cols)
                        );
                        az = Array.from({ length: rows }, (_, i) =>
                            az.slice(i * cols, (i + 1) * cols)
                        );

                        // console.log('bx not reshaped',bx)
                        bx = Array.from({ length: rows }, (_, i) =>
                            bx.slice(i * cols, (i + 1) * cols)
                        );
                        bz = Array.from({ length: rows }, (_, i) =>
                            bz.slice(i * cols, (i + 1) * cols)
                        );
                        stimx = [];
                        stimz = [];
                        ax_bx = ax.map((row, i) => row.concat(bx[i]));  //ax.concat(bx);
                        az_bz = az.map((row, i) => row.concat(bz[i]));  //ax.concat(bx);
                        min = Math.min(...ax_bx.flat());
                        max = Math.max(...ax_bx.flat());
                        min = Math.min(...az_bz.flat());
                        max = Math.max(...az_bz.flat());
                        // end of stim stuff

                        // start of noise stuff
                        NdotsToShowNoise = NnoiseDots;
                        // as framerate is 30Hz, I will change a dot every 4 frames, so to make the changes as asynchroneous as possible, I change as few dots as possible - that's 3 per frame
                        setBoundsNoise = linspace(0, NdotsToShowNoise, dotDur + 1) // start and stop of each quarter.
                        setBoundsNoise = setBoundsNoise.map(num => Math.ceil(num));
                        
                        possCoordsNoisex = transpose(ax_bx);
                        possCoordsNoisez = transpose(az_bz);
                        
                        // Initialize arrays (which are later combined to generate noise) with 0
                        offsetx = Array.from({ length: NnoiseDots }, () =>
                            Array(Nframes).fill(0)
                        );
                        offsetz = Array.from({ length: NnoiseDots }, () =>
                            Array(Nframes).fill(0)
                        );
                        timeWindow = Array.from({ length: NnoiseDots }, () =>
                            Array(Nframes).fill(0)
                        );
                        swapXZ = Array.from({ length: NnoiseDots }, () =>
                            Array(Nframes).fill(0)
                        );
                        flipX = Array.from({ length: NnoiseDots }, () =>
                            Array(Nframes).fill(1)
                        );
                        flipZ = Array.from({ length: NnoiseDots }, () =>
                            Array(Nframes).fill(1)
                        );
                        console.log('offsetx[0][0]:', offsetx[0][0]) // sanity check. should be 0

                        // Initialize `sel` as a 2D array with NnoiseDots rows and (Nframes + Nsets) columns, filled with NaN
                        sel = Array.from({ length: NnoiseDots }, () =>
                            Array(Nframes + Nsets).fill(NaN)
                        );
                        // Select and transform dots
                        f = 0; // Frame counter

                        while (f <= Nframes + Nsets) { // repmat not working!!!!!
                            for (s = 0; s < Nsets; s++) { // for each set of NnoiseDots/4 dots
                                const whichDots = Array.from(
                                    { length: setBoundsNoise[s + 1] - setBoundsNoise[s] },
                                    (_, i) => setBoundsNoise[s] + i
                                ); // should be something like 0-12, 12-24 etc
                                range = Array.from({ length: Ndots }, (_, i) => i); // 1:Ndots (1:26) --> inds from which to select stimuli
                                sampled = sampleFrom(Math.ceil(NnoiseDots / dotDur), range);  // sample 16 dots
                                // edit a quarter of dots
                                samp = -1;
                                whichDots.forEach((dot) => { // for each of the 12 dots (48 noisedots version). e.g. dot goes from 36 to 47
                                    samp++;
                                    // assign temporary values to each dot within the set
                                    main_dot_ind = sampled[samp] //selTemp[dot]; // sel has the dot number (wrt the main stim set) 
                                    // for each of the 48 dots and Nframes+4 frames
                                    offsetxTemp_ = (Math.random() - 0.5) * noiseSpread;
                                    offsetzTemp_ = (Math.random() - 0.5) * noiseSpread;
                                    timeWindowTemp_ = Math.floor(Math.random() * (Nframes - 3));
                                    swapXZTemp_ = Math.round(Math.random());
                                    flipXTemp_ = Math.random() < 0.5 ? -1 : 1;
                                    flipZTemp_ = Math.random() < 0.5 ? -1 : 1;

                                    for (ind = 0; ind < 4; ind++) { // repmat in matlab
                                        sel[dot][f + ind] = main_dot_ind
                                        offsetx[dot][f + ind] = offsetxTemp_ //offsetxTemp[dot]; // Random x-offset
                                        offsetz[dot][f + ind] = offsetzTemp_ //offsetzTemp[dot]; // Random z-offset
                                        timeWindow[dot][f + ind] = timeWindowTemp_ + ind; //timeWindowTemp[dot]+ind;
                                        swapXZ[dot][f + ind] = swapXZTemp_; // swapXZTemp[dot];
                                        flipX[dot][f + ind] = flipXTemp_; //flipXTemp[dot];
                                        flipZ[dot][f + ind] = flipZTemp_; //flipZTemp[dot];
                                    }
                                });
                                // console.log('offsetxTemp',offsetxTemp);
                                f++;
                            }
                        }
                        // Remove initial frames
                         sel = sel.map(row => row.slice(Nsets, Nframes + Nsets));
                        offsetx = offsetx.map(row => row.slice(Nsets, Nframes + Nsets));
                        offsetz = offsetz.map(row => row.slice(Nsets, Nframes + Nsets));

                        noisex = Array.from({ length: Nframes }, () =>
                            Array(NnoiseDots).fill(0)
                        );
                        noisez = Array.from({ length: Nframes }, () =>
                            Array(NnoiseDots).fill(0)
                        );


                        for (f = 0; f < Nframes; f++) {
                            for (d = 0; d < NnoiseDots; d++) {
                                if (swapXZ[d][f]) {
                                    // Perform coordinate swap and offset adjustment
                                    noisex[f][d] =
                                        flipX[d][f] *
                                        possCoordsNoisez[sel[d][f]][timeWindow[d][f]] +
                                        offsetx[d][timeWindow[d][f]]; // offsetx[sel[d][f]][timeWindow[d][f]];  just need 'd' here. E.g if the dot is 26 in the actual dot array, for the offset, it' still a value between 1 and Nnoisedots
                                    // noisex[f][d] =
                                    noisez[f][d] =
                                        flipZ[d][f] *
                                        possCoordsNoisex[sel[d][f]][timeWindow[d][f]] +
                                        offsetz[d][timeWindow[d][f]]; // offsetz[sel[d][f]][timeWindow[d][f]];
                                }
                                else {
                                    // Standard coordinate adjustment
                                    noisex[f][d] =
                                        flipX[d][f] *
                                        possCoordsNoisex[sel[d][f]][timeWindow[d][f]] +
                                        offsetx[d][timeWindow[d][f]]; //offsetx[sel[d][f]][timeWindow[d][f]];
                                    noisez[f][d] =
                                        flipZ[d][f] *
                                        possCoordsNoisez[sel[d][f]][timeWindow[d][f]] +
                                        offsetz[d][timeWindow[d][f]]; // //offsetz[sel[d][f]][timeWindow[d][f]];
                                }
                            }
                        }
                        // console.log('noisex.length',noisex.length, ', noisex[0]?.length || 0',  noisex[0]?.length || 0)
                        console.log('noisex', noisex)

                        /* shift and scale noise!! */
                        shift = 0;
                        scale = 100;
                        // Find the minimum and maximum values
                        min = Math.min(...noisex.flat());
                        max = Math.max(...noisex.flat());
                        console.log('before: noisex: min', min, ',max', max) // there is a bug already before!!
                        // Center and normalize the array
                        noisex = noisex.map(row => row.map(num => (num - min) / (max - min))); //noisex.map(num => (num - min) / (max - min));
                        noisex = noisex.map(row => row.map(num => num * scale + shift));
                        // console.log('ax after shift and scale',ax,typeof ax[0]); // Output: "number"
                        min = Math.min(...noisex.flat());
                        max = Math.max(...noisex.flat());
                        console.log('noisex after : min', min, ',max', max)

                        shift = 0//-30; // same shift and scale for both 
                        scale = 100 //100;
                        // vertical
                        // Find the minimum and maximum values
                        min = Math.min(...noisez.flat());
                        max = Math.max(...noisez.flat());

                        // Center and normalize the array
                        noisez = noisez.map(row => row.map(num => (num - min) / (max - min)));
                        noisez = noisez.map(row => row.map(num => num * scale + shift));

                        min = Math.min(...noisez.flat());
                        max = Math.max(...noisez.flat());

                        // end of noise stuff

                        for (f = 0; f < Nframes; f++) {
                            stimx.push(
                                selStim[f].map(index => {
                                    if (ax_bx[f][index - 1] === undefined) {
                                        console.error(`Undefined in stimx at frame ${f}, index ${index - 1}`);
                                    }
                                    return ax_bx[f][index - 1];
                                })
                            );

                            stimz.push(
                                selStim[f].map(index => {
                                    if (az_bz[f][index - 1] === undefined) {
                                        console.error(`Undefined in stimz at frame ${f}, index ${index - 1}`);
                                    }
                                    return az_bz[f][index - 1];
                                })
                            );
                        }
                        min = Math.min(...stimx.flat());
                        max = Math.max(...stimx.flat());
                        console.log('stimx: min', min, ',max', max)

                        min = Math.min(...stimz.flat());
                        max = Math.max(...stimz.flat());
                        console.log('stimz: min', min, ',max', max)

                        min = Math.min(...noisex.flat());
                        max = Math.max(...noisez.flat());
                        console.log('noisex: min', min, ',max', max)

                        min = Math.min(...noisex.flat());
                        max = Math.max(...noisez.flat());
                        console.log('noisez: min', min, ',max', max)

                        const container = document.getElementById("dot-container");
                        if (container) {
                            // container.replaceWith(createStimulusClip(stimx, stimz, Nframes, NstimDots));
                            container.replaceWith(createStimulusClip(stimx, stimz, noisex, noisez, NnoiseDots, Nframes, NstimDots));
                        } else {
                            console.error("Dot container not found!");
                        }
                        if (blockSeq[b] == 1) {
                            resp_choices = resp_choices_alltrials_response1[trialSeq[9*b+jj_within_block]]; //resp_choices_alltrials_response1;
                        }
                        if (blockSeq[b] == 2){
                            resp_choices = resp_choices_alltrials_response2[trialSeq[9*b+jj_within_block]];
                        }
                        console.log(resp_choices);
                    },
                    trial_duration: 3200 // End trial after 1 second (10 sets * .1 seconds)
                };
                timeline.push(dotTrial);

                function return_prompt(b){
                    if (blockSeq[b] == 1) {
                        prompt = 'Person 1 (initiator) said:'
                    }
                    if (blockSeq[b] == 2){
                        prompt = 'Person 2 (responder):'
                    }
                    return prompt;
                }

                function return_resp_choices(b,jj_within_block){
                    if (blockSeq[b] == 1) {
                        resp_choices = resp_choices_alltrials_response1[trialSeq[9*b+jj_within_block]]; //resp_choices_alltrials_response1;
                    }
                    if (blockSeq[b] == 2){
                        resp_choices = resp_choices_alltrials_response2[trialSeq[9*b+jj_within_block]];
                    }
                    return resp_choices;
                }

                respPage = {
                    type: jsPsychHtmlSliderResponse,
                    stimulus: '<p style="text-align: center;">'+return_prompt(b)+' </p>',
                    labels: return_resp_choices(b,jj_within_block),
                    prompt: " ",

                    // slider_start: 50,
                    slider_width: 400, // Width of the slider in pixels
                    require_movement: true,
                    // response_ends_trial:true,
                    on_load: function () {
                        jsPsych.data.get().addToLast({ nt: jj + 1, stim: stimAll[trialSeq[jj]], resp: return_resp_choices(b,jj_within_block) });
                        // jsPsych.data.get().addToLast({ nt: jj + 1, stim: stimAll[trialSeq[jj]], resp: resp_choices_block[trialSeq[jj]] });

                        // Hide the continue button
                        const button = document.querySelector('.jspsych-btn');
                        // const button = document.querySelector('.jspsych-html-slider-response .jspsych-btn');
                        if (button) {
                            button.style.display = 'none';
                        }

                        sliderContainer = document.querySelector('.jspsych-content');
                        sliderContainer.style.display = 'flex';
                        sliderContainer.style.justifyContent = 'center';
                        sliderContainer.style.alignItems = 'center';
                        sliderContainer.style.flexDirection = 'column';
                        sliderContainer.style.height = 'auto'; // Use 'auto' to prevent height from stretching
                        sliderContainer.style.maxHeight = '100vh'; // Prevent exceeding viewport height

                        // Adjust label font size and alignment
                        labels = document.querySelectorAll('.jspsych-html-slider-response-container span');
                        labels.forEach((label) => {
                            label.style.fontSize = '24px'; // Increase font size
                            label.style.marginTop = '10px'; // Add space below slider for labels
                        });

                        // Increase slider size
                        slider = document.querySelector('input[type="range"]');
                        slider.style.height = '15px'; // Adjust slider height
                        slider.style.width = '100%'; // Ensure it spans the container width
                        slider.style.margin = '20px 0'; // Add spacing above and below the slider

                        // Add padding to avoid altering global layout
                        sliderContainer.style.padding = '20px 0';

                        // Add event listener to end the trial when slider value changes
                        slider.addEventListener('change', () => {
                            const response = slider.value;
                            jsPsych.finishTrial({ slider_response: response });
                        });
                    },
                };
                timeline.push(respPage)
                // break;
            }
            
        }

        // feedback
        timeline.push({
            type: jsPsychSurveyHtmlForm,
            preamble: '<p>Feedback if any:</p>',
            html: `
                <p align="center"> 
                    <textarea id="feedback" 
                        class="textbox" 
                        style="width: 100%; height: 120px; font-size: 24px; padding: 5px; line-height: 1.5; text-align: left; vertical-align: top; font-family: Arial, Helvetica, sans-serif;" 
                        name="feedback" 
                        rows="5" 
                        required
                    ></textarea>
                    <br>
                </p>`,
            on_load: function () {
                buttons = document.querySelectorAll('.jspsych-btn');
                buttons.forEach(button => {
                    button.style.display = 'block';
                    button.style.margin = '0 auto';
                });
            }
        });

        endPage = {
            type: jsPsychSurveyHtmlForm,
            // stimulus:'<div class="center-stimulus"> Welcome!</div>',
            // stimulus: '<p style="text-align: center;">Welcome to this study!<br>Here you will watch several short animations and answer questions about them.</p>',
            html: '<p style="text-align: center; width: 400px">Great job!<br></p>',

            on_load: function () {
                buttons = document.querySelectorAll('.jspsych-btn');
                buttons.forEach(button => {
                    button.style.display = 'block';
                    button.style.margin = '0 auto';
                });
                const data = jsPsych.data.get().csv();
                // Save the data as a CSV file
                const prolificID = jsPsych.data.get().first(1).values()[0].prolific_id || 'Not available';
                const flname = `experiment_data_prelim_${prolificID}.csv`
                saveData(flname, data);
            }
        }
        timeline.push(endPage)

        jsPsych.run(timeline);

    </script>

</body>

</html>